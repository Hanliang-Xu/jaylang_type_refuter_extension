(**
   This module gives an implementation of the DDPA analysis.  It is parametric
   in the choice of context stack.
*)

open Batteries;;
open Jhupllib;;

open Core_ast;;
open Core_ast_pp;;
open Ddpa_abstract_ast;;
open Ddpa_analysis_logging;;
open Ddpa_context_stack;;
open Ddpa_graph;;
open Ddpa_utils;;
open Nondeterminism;;
open Pds_reachability_types_stack;;
open Pp_utils;;

let logger = Logger_utils.make_logger "Ddpa_analysis";;
let lazy_logger = Logger_utils.make_lazy_logger "Ddpa_analysis";;

module type Analysis_sig =
sig
  (** The type of the DDPA analysis generated by the module. *)
  type ddpa_analysis

  (** The context stack module for this analysis. *)
  module C : Context_stack;;

  (** The initial, unclosed analysis derived from an expression. *)
  val create_initial_analysis :
    ?ddpa_logging_config:(ddpa_analysis_logging_config option) ->
    expr -> ddpa_analysis

  (** Pretty-prints a DDPA structure. *)
  val pp_ddpa_analysis : ddpa_analysis pretty_printer
  val show_ddpa_analysis : ddpa_analysis -> string

  (** Get size of DDPA and underlying PDS. *)
  val get_size : ddpa_analysis -> int * int * int * int * int

  (** Performs a series of closure steps on an analysis.  This is not guaranteed
      to complete closure; however, it will make progress as long as the
      argument is not fully closed. *)
  val perform_closure_steps : ddpa_analysis -> ddpa_analysis

  (** Determines if an analysis is fully closed. *)
  val is_fully_closed : ddpa_analysis -> bool

  (** Fully closes an analysis. *)
  val perform_full_closure : ddpa_analysis -> ddpa_analysis

  (** Determines the values at a given position of the provided variable in the
      given analysis.  This is an approximation -- false positives may arise --
      but it is guaranteed to be conservative if the analysis is fully closed.
      The returned analysis contains a cache structure to accelerate answering
      of this question in the future. *)
  val values_of_variable :
    var -> annotated_clause -> ddpa_analysis ->
    Abs_filtered_value_set.t * ddpa_analysis

  val contextual_values_of_variable :
    var -> annotated_clause -> C.t -> ddpa_analysis ->
    Abs_filtered_value_set.t * ddpa_analysis
end;;

(**
   A functor which constructs a DDPA analysis module.
*)
module Make(C : Context_stack)
  : Analysis_sig with module C = C =
struct
  module C = C;;
  module Structure_types = Ddpa_pds_structure_types.Make(C);;
  module Dynamic_pop_types =
    Ddpa_pds_dynamic_pop_types.Make(C)(Structure_types)
  ;;
  module Dynamic_pop_handler =
    Ddpa_pds_dynamic_pop_handler.Make(C)(Structure_types)(Dynamic_pop_types)
  ;;

  module Ddpa_pds_reachability_basis =
  struct
    module State = Structure_types.Pds_state;;
    module Stack_element = Structure_types.Pds_continuation;;
  end

  module Ddpa_pds_reachability =
    Pds_reachability.Make
      (Ddpa_pds_reachability_basis)
      (Dynamic_pop_handler)
      (Pds_reachability_work_collection_templates.Work_stack)
  ;;

  open Structure_types;;
  open Dynamic_pop_types;;

  type ddpa_analysis_logging_data =
    { ddpa_logging_config : ddpa_analysis_logging_config
    ; ddpa_closure_steps : int
    }
    [@@deriving show]
  ;;
  let _ = show_ddpa_analysis_logging_data;;

  type ddpa_analysis =
    { ddpa_graph : ddpa_graph
    ; ddpa_graph_fully_closed : bool
    ; pds_reachability : Ddpa_pds_reachability.analysis
    ; ddpa_active_nodes : Annotated_clause_set.t
    (** The active nodes in the DDPA graph.  This set is maintained
            incrementally as edges are added. *)
    ; ddpa_active_non_immediate_nodes : Annotated_clause_set.t
    (** A subset of [ddpa_active_nodes] which only contains the
        non-immediate nodes.  This is useful during closure. *)
    ; ddpa_logging_data : ddpa_analysis_logging_data option
    (** Data associated with logging, if appropriate. *)
    }
    [@@deriving show]
  ;;

  let dump_yojson analysis =
    `Assoc
      [ ( "ddpa_graph"
        , Ddpa_graph.to_yojson analysis.ddpa_graph
        )
      ; ( "ddpa_graph_fully_closed"
        , `Bool analysis.ddpa_graph_fully_closed
        )
      ; ( "ddpa_active_nodes"
        , Annotated_clause_set.to_yojson analysis.ddpa_active_nodes
        )
      ; ("ddpa_active_non_immediate_nodes"
        , Annotated_clause_set.to_yojson
            analysis.ddpa_active_non_immediate_nodes
        )
      ]
  ;;

  (** Logs a given PDS reachability graph.  This only occurs if the logging
      level of the analysis is at least as high as the one provided in this
      call.  The graph to be logged defaults to the analysis but can be
      overridden (e.g. in the logger given to that analysis). *)
  let log_pdr level ddpa_logging_data_opt reachability =
    match ddpa_logging_data_opt with
    | None -> ()
    | Some data ->
      if compare_ddpa_logging_level
          data.ddpa_logging_config.ddpa_pdr_logging_level
          level >= 0
      then
        begin
          let json =
            `Assoc
              [ ( "element_type"
                , `String "pds_reachability_graph"
                )
              ; ( "work_count"
                , `Int (Ddpa_pds_reachability.get_work_count reachability)
                )
              ; ( "graph"
                , Ddpa_pds_reachability.dump_yojson reachability
                )
              ]
          in
          data.ddpa_logging_config.ddpa_json_logger json
        end
  ;;

  (** As log_pdr, but logs a delta of the reachability graph. *)
  let log_pdr_delta
      level ddpa_logging_data_opt old_reachability new_reachability =
    match ddpa_logging_data_opt with
    | None -> ()
    | Some data ->
      if compare_ddpa_logging_level
          data.ddpa_logging_config.ddpa_pdr_logging_level
          level >= 0
      then
        begin
          let json =
            `Assoc
              [ ( "element_type"
                , `String "pds_reachability_graph_delta"
                )
              ; ( "work_count"
                , `Int (Ddpa_pds_reachability.get_work_count new_reachability)
                )
              ; ( "graph"
                , Ddpa_pds_reachability.dump_yojson_delta
                    old_reachability new_reachability
                )
              ]
          in
          data.ddpa_logging_config.ddpa_json_logger json
        end
  ;;

  (** Logs a given DDPA control flow graph.  This only occurs if the logging
      level of the analysis is at least as high as the one provided in this
      call. *)
  let log_cfg level analysis =
    match analysis.ddpa_logging_data with
    | None -> ()
    | Some data ->
      if compare_ddpa_logging_level
          data.ddpa_logging_config.ddpa_cfg_logging_level
          level >= 0
      then
        begin
          let json =
            `Assoc
              [ ( "element_type"
                , `String "ddpa_graph"
                )
              ; ( "work_count"
                , `Int (Ddpa_pds_reachability.get_work_count
                          analysis.pds_reachability)
                )
              ; ( "graph"
                , dump_yojson analysis
                )
              ]
          in
          data.ddpa_logging_config.ddpa_json_logger json
        end
  ;;

  let get_size analysis =
    let pds_node_count, pds_edge_count =
      Ddpa_pds_reachability.get_size analysis.pds_reachability
    in
    let filter_inferrable_nodes nodes =
      nodes
      |> Annotated_clause_set.filter (
        fun node ->
          match node with
          | Enter_clause _
          | Exit_clause _ -> false
          | _ -> true
      )
    in
    Annotated_clause_set.cardinal (filter_inferrable_nodes analysis.ddpa_active_nodes),
    Annotated_clause_set.cardinal (filter_inferrable_nodes analysis.ddpa_active_non_immediate_nodes),
    analysis.ddpa_graph
    |> edges_of
    |> List.of_enum
    |> List.length,
    pds_node_count,
    pds_edge_count
  ;;

  let empty_analysis ?ddpa_logging_data_opt:(ddpa_logging_data_opt=None) () =
    (* Make sure to log PDR closure too if appropriate. *)
    let pdr_log_fn_opt =
      match ddpa_logging_data_opt with
      | None -> None
      | Some ddpa_logging_data ->
        if ddpa_logging_data.ddpa_logging_config.ddpa_pdr_logging_level
           = Log_nothing
        then None
        else Some
            (fun old_reachability new_reachability ->
               if ddpa_logging_data.ddpa_logging_config.ddpa_pdr_deltas
               then
                 log_pdr_delta Log_everything ddpa_logging_data_opt
                   old_reachability new_reachability
               else
                 log_pdr Log_everything ddpa_logging_data_opt new_reachability)
    in
    (* The initial reachability analysis should include an edge function which
       always allows discarding the bottom-of-stack marker. *)
    let initial_reachability =
      Ddpa_pds_reachability.empty ~logging_function:pdr_log_fn_opt ()
      |> Ddpa_pds_reachability.add_edge_function
        (fun state ->
           Enum.singleton ([Pop Structure_types.Bottom_of_stack], state)
        )
    in
    { ddpa_graph = Ddpa_graph.empty
    ; ddpa_graph_fully_closed = true
    ; pds_reachability = initial_reachability
    ; ddpa_active_nodes = Annotated_clause_set.singleton Start_clause
    ; ddpa_active_non_immediate_nodes = Annotated_clause_set.empty
    ; ddpa_logging_data = ddpa_logging_data_opt
    }
  ;;

  let end_of_scope annotated_clause edges =
    let rec step annotated_clause visited_annotated_clauses =
      match annotated_clause with
      | Exit_clause _
      | End_clause -> annotated_clause
      | _ ->
        edges
        |> Enum.clone
        |> Enum.filter_map (
          fun (Ddpa_edge(source, target)) ->
            if (equal_annotated_clause annotated_clause source) &&
               (not (Annotated_clause_set.mem target visited_annotated_clauses))
            then
              match target with
              | Enter_clause _ -> None
              | _ -> Some target
            else
              None
        )
        |> Enum.get
        |> (
          function
          | Some successor ->
            step successor (Annotated_clause_set.add annotated_clause visited_annotated_clauses)
          | None ->
            annotated_clause
        )
    in
    step annotated_clause Annotated_clause_set.empty
  ;;

  let add_edges edges_in analysis =
    let edges =
      edges_in
      |> Enum.filter
        (fun edge -> not @@ Ddpa_graph.has_edge edge analysis.ddpa_graph)
    in
    if Enum.is_empty edges then (analysis,false) else
      (* ***
         First, update the PDS reachability analysis with the new edge
         information.
      *)
      let add_edge_for_reachability edge reachability =
        (* Unpack the edge *)
        let (Ddpa_edge(acl1,acl0)) = edge in
        (* Create an edge function to generate targeted dynamic pops for each
           edge. *)
        let edge_function state =
          Logger_utils.lazy_bracket_log (lazy_logger `trace)
            (fun () -> Printf.sprintf "DDPA %s edge function at state %s"
                (show_ddpa_edge edge) (Pds_state.show state))
            (fun edges ->
               let string_of_output (actions,target) =
                 String_utils.string_of_tuple
                   (String_utils.string_of_list
                      Ddpa_pds_reachability.show_stack_action)
                   Pds_state.show
                   (actions,target)
               in
               Printf.sprintf "Generates edges: %s"
                 (String_utils.string_of_list string_of_output @@
                  List.of_enum @@ Enum.clone edges)) @@
          fun () ->
          let zero = Enum.empty in
          let%orzero Program_point_state(acl0',ctx) = state in
          (* TODO: There should be a way to associate each edge function with
                   its corresponding acl0 rather than using this guard. *)
          [%guard (compare_annotated_clause acl0 acl0' == 0) ];
          let open Option.Monad in
          let zero () = None in
          (* TODO: It'd be nice if we had a terser way to represent stack
                   processing operations (those that simply reorder the stack
                   without transitioning to a different node). *)
          let targeted_dynamic_pops = Enum.filter_map identity @@ List.enum
              [
                (* 1b. Value drop *)
                begin
                  return (Value_drop, Program_point_state(acl0,ctx))
                end
                ;
                (* 2a. Transitivity *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x, Abs_var_body x'))) = acl1
                  in
                  (* x = x' *)
                  return (Variable_aliasing(x,x'),Program_point_state(acl1,ctx))
                end
                ;
                (* 2b. Stateless non-matching clause skip *)
                begin
                  let%orzero (Unannotated_clause(Abs_clause(x,_))) = acl1 in
                  (* x' = b *)
                  return ( Stateless_nonmatching_clause_skip_1_of_2 x
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 3b. Value capture *)
                begin
                  return ( Value_capture_1_of_3
                         , Program_point_state(acl0, ctx)
                         )
                end
                ;
                (* 3c. Rewind *)
                begin
                  return ( Rewind_step(end_of_scope acl0 edges, ctx)
                         , Program_point_state(acl0, ctx)
                         )
                end
                ;
                (* 4a. Function parameter wiring *)
                begin
                  let%orzero (Enter_clause(x,x',c)) = acl1 in
                  let%orzero (Abs_clause(_,Abs_appl_body (_,x3''))) = c in
                  begin
                    if not (equal_var x' x3'') then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  (* x =(down)c x' *)
                  [%guard C.is_top c ctx];
                  let ctx' = C.pop ctx in
                  return (Variable_aliasing(x,x'),Program_point_state(acl1,ctx'))
                end
                ;
                (* 4b. Function return wiring start *)
                begin
                  let%orzero (Exit_clause(x,_,c)) = acl1 in
                  let%orzero (Abs_clause(x1'',Abs_appl_body(x2'',x3''))) = c in
                  begin
                    if not (equal_var x x1'') then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  (* x =(up)c _ (for functions) *)
                  return ( Function_call_flow_validation(x2'',x3'',acl0,ctx,Unannotated_clause(c),ctx,x)
                         , Program_point_state(Unannotated_clause(c),ctx)
                         )
                end
                ;
                (* 4c. Function return wiring finish *)
                begin
                  let%orzero (Exit_clause(x,x',c)) = acl1 in
                  let%orzero (Abs_clause(x1'',Abs_appl_body _)) = c in
                  begin
                    if not (equal_var x x1'') then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  (* x =(up)c x' *)
                  let ctx' = C.push c ctx in
                  return ( Function_call_flow_validation_resolution_1_of_2(x,x')
                         , Program_point_state(acl1,ctx')
                         )
                end
                ;
                (* 4d. Function non-local wiring *)
                begin
                  let%orzero (Enter_clause(x'',x',c)) = acl1 in
                  let%orzero (Abs_clause(_,Abs_appl_body(x2'',x3''))) = c in
                  begin
                    if not (equal_var x' x3'') then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  (* x'' =(down)c x' *)
                  [%guard C.is_top c ctx];
                  let ctx' = C.pop ctx in
                  return ( Function_closure_lookup(x'',x2'')
                         , Program_point_state(acl1,ctx')
                         )
                end
                ;
                (* 5a, 5b, and 5e. Conditional entrance wiring *)
                begin
                  (* This block represents *all* conditional closure handling on
                     the entering side. *)
                  let%orzero (Enter_clause(x',x1,c)) = acl1 in
                  let%orzero
                    (Abs_clause(_,Abs_conditional_body(x1',p,f1,_))) = c
                  in
                  begin
                    if not (equal_var x1 x1') then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  let Abs_function_value(f1x,_) = f1 in
                  (* x'' =(down)c x' for conditionals *)
                  let closure_for_positive_path = equal_var f1x x' in
                  return ( Conditional_closure_lookup
                             (x',x1,p,closure_for_positive_path)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 5c, 5d. Conditional return wiring *)
                begin
                  let%orzero (Exit_clause(x,x',c)) = acl1 in
                  let%orzero
                    (Abs_clause(x2,Abs_conditional_body(x1,pat,f1,_))) = c
                  in
                  begin
                    if not (equal_var x x2) then
                      raise @@ Utils.Invariant_failure "Ill-formed wiring node."
                    else
                      ()
                  end;
                  (* x =(up) x' for conditionals *)
                  let Abs_function_value(_,Abs_expr(cls)) = f1 in
                  let f1ret = rv cls in
                  let then_branch = equal_var f1ret x' in
                  return ( Conditional_subject_validation(
                      x,x',x1,pat,then_branch,acl1,ctx)
                         , Program_point_state(Unannotated_clause(c),ctx)
                    )
                end
                ;
                (* 6a. Record destruction *)
                begin
                  let%orzero
                    (Unannotated_clause(
                        Abs_clause(x,Abs_projection_body(x',l)))) = acl1
                  in
                  (* x = x'.l *)
                  return ( Record_projection_lookup(x,x',l)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 6b. Record projection *)
                begin
                  return ( Record_projection_1_of_2
                         , Program_point_state(acl0,ctx)
                         )
                end
                ;
                (* 7a. Function filter validation *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         x,Abs_value_body(Abs_value_function(v))))) = acl1
                  in
                  (* x = f *)
                  return ( Function_filter_validation(x,v)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 7b. Record validation *)
                begin
                  let%orzero
                    (Unannotated_clause(
                        Abs_clause(x,Abs_value_body(Abs_value_record(r))))) = acl1
                  in
                  (* x = r *)
                  let target_state = Program_point_state(acl1,ctx) in
                  return ( Record_filter_validation(
                      x,r,acl1,ctx)
                         , target_state
                    )
                end
                ;
                (* 7c. Integer filter validation *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         x,Abs_value_body(Abs_value_int)))) = acl1
                  in
                  (* x = int *)
                  return ( Int_filter_validation(x)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 7d, 7e. Boolean filter validation *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         x,Abs_value_body(Abs_value_bool(b))))) = acl1
                  in
                  (* x = true OR x = false *)
                  return ( Bool_filter_validation(x,b)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 7f. String filter validation *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         x,Abs_value_body(Abs_value_string)))) = acl1
                  in
                  (* x = <string> *)
                  return ( String_filter_validation(x)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 8a. Assignment result *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x, Abs_update_body _))) = acl1
                  in
                  (* x = x' <- x'' -- produce {} for x *)
                  return ( Empty_record_value_discovery x
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 8b. Dereference lookup *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x, Abs_deref_body(x')))) = acl1
                  in
                  (* x = !x' *)
                  return ( Dereference_lookup(x,x')
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 8c. Cell validation *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         x,Abs_value_body(Abs_value_ref(cell))))) = acl1
                  in
                  (* x = ref x' *)
                  return ( Cell_filter_validation(x,cell)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ;
                (* 8d. Cell dereference *)
                begin
                  return ( Cell_dereference_1_of_2
                         , Program_point_state(acl0, ctx) )
                end
                ;
                (* 9a. Cell update alias analysis initialization *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         _, Abs_update_body(x',_)))) = acl1
                  in
                  (* x''' = x' <- x'' *)
                  let source_state = Program_point_state(acl1,ctx) in
                  let target_state = Program_point_state(acl0,ctx) in
                  return ( Cell_update_alias_analysis_init_1_of_2(
                      x',source_state,target_state)
                         , Program_point_state(acl0, ctx) )
                end
                ; (* 9b,9c. Alias resolution *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(
                         _, Abs_update_body(_,x'')))) = acl1
                  in
                  (* x''' = x' <- x'' *)
                  return ( Alias_analysis_resolution_1_of_5(x'')
                         , Program_point_state(acl1, ctx) )
                end
                ; (* 10a. Stateful non-side-effecting clause skip *)
                begin
                  let%orzero (Unannotated_clause(Abs_clause(x,b))) = acl1 in
                  [% guard (is_immediate acl1) ];
                  [% guard (b |>
                            (function
                              | Abs_update_body _ -> false
                              | _ -> true)) ];
                  (* x' = b *)
                  return ( Nonsideeffecting_nonmatching_clause_skip x
                         , Program_point_state(acl1,ctx)
                         )
                end
                ; (* 10b. Side-effect search initialization *)
                begin
                  let%orzero (Exit_clause(x'',_,c)) = acl1 in
                  (* x'' =(up)c x' *)
                  let%bind ctx' =
                    match c with
                    | Abs_clause(_,Abs_appl_body _) -> return @@ C.push c ctx
                    | Abs_clause(_,Abs_conditional_body _) -> return ctx
                    | _ -> zero ()
                  in
                  return ( Side_effect_search_init_1_of_2(x'',acl0,ctx)
                         , Program_point_state(acl1,ctx') )
                end
                ; (* 10c. Side-effect search non-matching clause skip *)
                begin
                  let%orzero (Unannotated_clause(Abs_clause(_,b))) = acl1 in
                  [% guard (is_immediate acl1) ];
                  [% guard (b |>
                            (function
                              | Abs_update_body _ -> false
                              | _ -> true)) ];
                  (* x' = b *)
                  return ( Side_effect_search_nonmatching_clause_skip
                         , Program_point_state(acl1,ctx) )
                end
                ; (* 10d. Side-effect search exit wiring node *)
                begin
                  let%orzero (Exit_clause(_,_,c)) = acl1 in
                  (* x'' =(up)c x' *)
                  let%bind ctx' =
                    match c with
                    | Abs_clause(_,Abs_appl_body _) -> return @@ C.push c ctx
                    | Abs_clause(_,Abs_conditional_body _) -> return ctx
                    | _ -> zero ()
                  in
                  return ( Side_effect_search_exit_wiring
                         , Program_point_state(acl1,ctx') )
                end
                ; (* 10e. Side-effect search enter wiring node *)
                begin
                  let%orzero (Enter_clause(_,_,c)) = acl1 in
                  (* x'' =(down)c x' *)
                  let%bind ctx' =
                    match c with
                    | Abs_clause(_,Abs_appl_body _) -> return @@ C.pop ctx
                    | Abs_clause(_,Abs_conditional_body _) -> return ctx
                    | _ -> zero ()
                  in
                  return ( Side_effect_search_enter_wiring
                         , Program_point_state(acl1,ctx') )
                end
                (* FIXME: why does this clause kill performance? *)
                ; (* 10f. Side-effect search without discovery *)
                begin
                  return ( Side_effect_search_without_discovery
                         , Program_point_state(acl0,ctx) )
                end
                ; (* 10g. Side-effect search alias analysis initialization *)
                begin
                  let%orzero (Unannotated_clause(
                      Abs_clause(_,Abs_update_body(x',_)))) = acl1
                  in
                  return ( Side_effect_search_alias_analysis_init(x',acl0,ctx)
                         , Program_point_state(acl1,ctx) )
                end
                ; (* 10h,10i. Side-effect search alias analysis resolution *)
                begin
                  let%orzero (Unannotated_clause(
                      Abs_clause(_,Abs_update_body(_,x'')))) = acl1
                  in
                  return ( Side_effect_search_alias_analysis_resolution_1_of_4(
                      x'')
                         , Program_point_state(acl1,ctx) )
                end
                ; (* 10j. Side-effect search escape *)
                begin
                  return ( Side_effect_search_escape_1_of_2
                         , Program_point_state(acl0,ctx) )
                end
                ; (* 10k. Side-effect search escape completion *)
                begin
                  return ( Side_effect_search_escape_completion_1_of_4
                         , Program_point_state(acl0,ctx) )
                end
                ; (* 11a. Binary operation operand lookup *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_binary_operation_body(x2,_,x3)))) = acl1
                  in
                  (* x1 = x2 op x3 *)
                  return ( Binary_operator_lookup_init(
                      x1,x2,x3,acl1,ctx,acl0,ctx)
                         , Program_point_state(acl1,ctx)
                    )
                end
                ; (* 11b. Unary operation operand lookup *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_unary_operation_body(_,x2)))) = acl1
                  in
                  (* x1 = op x2 *)
                  return ( Unary_operator_lookup_init(
                      x1,x2,acl0,ctx)
                         , Program_point_state(acl1,ctx)
                    )
                end
                ; (* 11c. Indexing lookup *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_indexing_body(x2,x3)))) = acl1
                  in
                  (* x1 = x2[x3] *)
                  return ( Indexing_lookup_init(
                      x1,x2,x3,acl1,ctx,acl0,ctx)
                         , Program_point_state(acl1,ctx)
                    )
                end
                ; (* 12a,12b,12c,13a,13b,13c,13d,13e,13f,13g,13h,13i,13j,13k,13l,14a,14b,14c. Binary operator resolution *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_binary_operation_body(_,op,_)))) = acl1
                  in
                  (* x1 = x2 op x3 *)
                  return ( Binary_operator_resolution_1_of_4(x1,op)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ; (* 13m,13n. Unary operator resolution *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_unary_operation_body(op,_)))) = acl1
                  in
                  (* x1 = op x2 *)
                  return ( Unary_operator_resolution_1_of_3(x1,op)
                         , Program_point_state(acl1,ctx)
                         )
                end
                ; (* 14d. Indexing resolution *)
                begin
                  let%orzero
                    (Unannotated_clause(Abs_clause(x1,
                                                   Abs_indexing_body(_,_)))) = acl1
                  in
                  (* x1 = x2[x3] *)
                  return ( Indexing_resolution_1_of_4(x1)
                         , Program_point_state(acl1,ctx)
                         )
                end
              ]
          in
          targeted_dynamic_pops
          |> Enum.map
            (fun (action,state) -> ([Pop_dynamic_targeted(action)], state))
        in
        (* Create another function to handle the untargeted dynamic pops. *)
        let untargeted_dynamic_pop_action_function state =
          let zero = Enum.empty in
          let%orzero Program_point_state(acl0',_) = state in
          (* TODO: There should be a way to associate each action function with
                   its corresponding acl0 rather than using this guard. *)
          [%guard (compare_annotated_clause acl0 acl0' == 0)];
          let open Option.Monad in
          let untargeted_dynamic_pops = Enum.filter_map identity @@ List.enum
              [
                (* 1a. Value discovery. *)
                begin
                  return @@ Value_discovery_1_of_2
                end
                ;
                (* 3a. Jump. *)
                begin
                  return @@ Do_jump
                end
              ]
          in
          untargeted_dynamic_pops
        in
        (* Put it all together with the reachability parameter to produce the
           new reachability structure. *)
        reachability
        |> Ddpa_pds_reachability.add_edge_function edge_function
        |> Ddpa_pds_reachability.add_untargeted_dynamic_pop_action_function
          untargeted_dynamic_pop_action_function
      in
      let pds_reachability' =
        Enum.clone edges
        |> Enum.fold (flip add_edge_for_reachability) analysis.pds_reachability
      in
      (* ***
         Next, add the edge to the DDPA graph.
      *)
      let ddpa_graph' =
        Enum.clone edges
        |> Enum.fold (flip Ddpa_graph.add_edge) analysis.ddpa_graph
      in
      (* ***
         Now, perform closure over the active node set.  This function uses a
         list of enumerations of nodes to explore.  This reduces the cost of
         managing the work queue.
      *)
      let rec find_new_active_nodes from_acls_enums results_so_far =
        match from_acls_enums with
        | [] -> results_so_far
        | from_acls_enum::from_acls_enums' ->
          if Enum.is_empty from_acls_enum
          then find_new_active_nodes from_acls_enums' results_so_far
          else
            let from_acl = Enum.get_exn from_acls_enum in
            if Annotated_clause_set.mem from_acl analysis.ddpa_active_nodes ||
               Annotated_clause_set.mem from_acl results_so_far
            then find_new_active_nodes from_acls_enums results_so_far
            else
              let results_so_far' =
                Annotated_clause_set.add from_acl results_so_far
              in
              let from_here = ddpa_graph' |> Ddpa_graph.succs from_acl in
              find_new_active_nodes (from_here::from_acls_enums) results_so_far'
      in
      let (ddpa_active_nodes',ddpa_active_non_immediate_nodes') =
        let new_active_root_nodes =
          Enum.clone edges
          |> Enum.filter_map
            (fun (Ddpa_edge(acl_left,acl_right)) ->
               if Annotated_clause_set.mem acl_left analysis.ddpa_active_nodes
               then Some acl_right
               else None)
          |> Enum.filter
            (fun acl ->
               not @@ Annotated_clause_set.mem acl analysis.ddpa_active_nodes)
        in
        let new_active_nodes =
          find_new_active_nodes [new_active_root_nodes]
            Annotated_clause_set.empty
        in
        ( Annotated_clause_set.union analysis.ddpa_active_nodes
            new_active_nodes
        , Annotated_clause_set.union analysis.ddpa_active_non_immediate_nodes
            ( new_active_nodes |> Annotated_clause_set.filter
                (not % is_annotated_clause_immediate) )
        )
      in
      (
        { ddpa_graph = ddpa_graph'
        ; ddpa_graph_fully_closed = false
        ; pds_reachability =  pds_reachability'
        ; ddpa_active_nodes = ddpa_active_nodes'
        ; ddpa_active_non_immediate_nodes = ddpa_active_non_immediate_nodes'
        ; ddpa_logging_data = analysis.ddpa_logging_data
        }
      , true
      )
  ;;

  let create_initial_analysis
      ?ddpa_logging_config:(ddpa_logging_config_opt=None)
      e =
    let logging_data =
      match ddpa_logging_config_opt with
      | None -> None
      | Some config ->
        Some { ddpa_logging_config = config
             ; ddpa_closure_steps = 0 (* FIXME: this number never changes or gets reported! *)
             }
    in
    let Abs_expr(cls) = lift_expr e in
    (* Put the annotated clauses together. *)
    let acls =
      List.enum cls
      |> Enum.map (fun x -> Unannotated_clause x)
      |> Enum.append (Enum.singleton Start_clause)
      |> flip Enum.append (Enum.singleton End_clause)
    in
    (* For each pair, produce a DDPA edge. *)
    let rec mk_edges acls' =
      match Enum.get acls' with
      | None -> []
      | Some acl1 ->
        match Enum.peek acls' with
        | None -> []
        | Some acl2 ->
          Ddpa_edge(acl1,acl2) :: mk_edges acls'
    in
    let edges = List.enum @@ mk_edges acls in
    let analysis =
      fst @@ add_edges edges @@
      empty_analysis ~ddpa_logging_data_opt:logging_data ()
    in
    logger `trace "Created initial analysis";
    log_cfg Log_everything analysis;
    log_pdr Log_everything analysis.ddpa_logging_data analysis.pds_reachability;
    analysis
  ;;

  let restricted_values_of_variable x acl ctx patsp patsn analysis =
    Logger_utils.lazy_bracket_log (lazy_logger `trace)
      (fun () ->
         Printf.sprintf "Determining values of variable %s at position %s%s"
           (show_var x) (show_annotated_clause acl) @@
         if Pattern_set.is_empty patsp && Pattern_set.is_empty patsn
         then ""
         else
           Printf.sprintf " with pattern sets %s and %s"
             (Pattern_set.show patsp) (Pattern_set.show patsn)
      )
      (fun (values, _) ->
         let pp formatter values =
           pp_concat_sep_delim "{" "}" ", " pp_abs_filtered_value formatter @@
           Enum.clone values
         in
         pp_to_string pp values
      )
    @@ fun () ->
    let start_state = Program_point_state(acl,ctx) in
    let start_actions =
      [Push Bottom_of_stack; Push (Lookup_var(x,patsp,patsn))]
    in
    let reachability = analysis.pds_reachability in
    let reachability' =
      reachability
      |> Ddpa_pds_reachability.add_start_state start_state start_actions
      |> Ddpa_pds_reachability.fully_close
    in
    let analysis' = { analysis with pds_reachability = reachability' } in
    let values =
      reachability'
      |> Ddpa_pds_reachability.get_reachable_states start_state start_actions
      |> Enum.filter_map
        (function
          | Program_point_state _ -> None
          | Result_state v -> Some v)
    in
    (values, analysis')
  ;;

  let values_of_variable x acl analysis =
    let (values, analysis') =
      restricted_values_of_variable x acl C.empty
        Pattern_set.empty Pattern_set.empty analysis
    in
    (Abs_filtered_value_set.of_enum values, analysis')
  ;;

  let contextual_values_of_variable x acl ctx analysis =
    let (values, analysis') =
      restricted_values_of_variable x acl ctx
        Pattern_set.empty Pattern_set.empty analysis
    in
    (Abs_filtered_value_set.of_enum values, analysis')
  ;;

  let wire site_cl func x1 x2 graph =
    let site_acl = Unannotated_clause(site_cl) in
    let Abs_function_value(x0, Abs_expr(body)) = func in
    let wire_in_acl = Enter_clause(x0,x1,site_cl) in
    let wire_out_acl = Exit_clause(x2,rv body,site_cl) in
    let pred_edges =
      Ddpa_graph.preds site_acl graph
      |> Enum.map (fun acl' -> Ddpa_edge(acl',wire_in_acl))
    in
    let succ_edges =
      Ddpa_graph.succs site_acl graph
      |> Enum.map (fun acl' -> Ddpa_edge(wire_out_acl,acl'))
    in
    let inner_edges =
      List.enum body
      |> Enum.map (fun cl -> Unannotated_clause(cl))
      |> Enum.append (Enum.singleton wire_in_acl)
      |> flip Enum.append (Enum.singleton wire_out_acl)
      |> Utils.pairwise_enum_fold
        (fun acl1 acl2 -> Ddpa_edge(acl1,acl2))
    in
    Enum.append pred_edges @@ Enum.append inner_edges succ_edges
  ;;

  let perform_closure_steps analysis =
    begin
      match analysis.ddpa_logging_data with
      | None -> lazy_logger `trace (fun () -> "Performing closure step")
      | Some data -> lazy_logger `trace (fun () ->
          (Printf.sprintf "Performing closure step %d"
             (data.ddpa_closure_steps+1)));
    end;
    (* We need to do work on each of the active, non-immediate nodes.  This
       process includes variable lookups, which may result in additional work
       being done; as a result, each closure step might change the underlying
       graph.  We'll keep the analysis in a ref so that, whenever work is done
       which produces a new analysis, we can just update the ref. *)
    let analysis_ref = ref analysis in
    let new_edges_enum = Nondeterminism_monad.enum
        (
          let open Nondeterminism_monad in
          let%bind acl =
            pick_enum @@
            Annotated_clause_set.enum analysis.ddpa_active_non_immediate_nodes
          in
          let has_values x patsp patsn =
            let (values,analysis') =
              restricted_values_of_variable
                x acl C.empty patsp patsn !analysis_ref
            in
            analysis_ref := analysis';
            not @@ Enum.is_empty values
          in
          match acl with
          | Unannotated_clause(Abs_clause(x1,Abs_appl_body(x2,x3)) as cl) ->
            lazy_logger `trace
              (fun () ->
                 Printf.sprintf "Considering application closure for clause %s"
                   (show_abstract_clause cl));
            (* Make sure that a value shows up to the argument. *)
            [%guard has_values x3 Pattern_set.empty Pattern_set.empty];
            (* Get each of the function values. *)
            let (x2_values,analysis_2) =
              restricted_values_of_variable
                x2 acl C.empty Pattern_set.empty Pattern_set.empty !analysis_ref
            in
            analysis_ref := analysis_2;
            let%bind x2_value = pick_enum x2_values in
            let%orzero
              Abs_filtered_value(Abs_value_function(fn),_,_) = x2_value
            in
            (* Wire each one in. *)
            return @@ wire cl fn x3 x1 analysis_2.ddpa_graph
          | Unannotated_clause(
              Abs_clause(x1,Abs_conditional_body(x2,p,f1,f2)) as cl) ->
            lazy_logger `trace
              (fun () ->
                 Printf.sprintf "Considering conditional closure for clause %s"
                   (show_abstract_clause cl));
            (* We have two functions we may wish to wire: f1 (if x2 has values
               which match the pattern) and f2 (if x2 has values which antimatch
               the pattern). *)
            [ (Pattern_set.singleton p, Pattern_set.empty, f1)
            ; (Pattern_set.empty, Pattern_set.singleton p, f2)
            ]
            |> List.enum
            |> Enum.filter_map
              (fun (patsp,patsn,f) ->
                 if has_values x2 patsp patsn then Some f else None)
            |> Enum.map (fun f -> wire cl f x2 x1 (!analysis_ref).ddpa_graph)
            |> Nondeterminism_monad.pick_enum
          | _ ->
            raise @@ Utils.Invariant_failure
              "Unhandled clause in perform_closure_steps"
        )
                         |> Enum.concat
    in
    (* Due to the stateful effects of computing the new edges, we're going to
       want to pull on the entire enumeration before we start looking at the
       analysis. *)
    let new_edges_list = List.of_enum new_edges_enum in
    (* Now we want to add all of the new edges.  If there are any new ones, we
       need to know about it. *)
    let (analysis',any_new) =
      add_edges (List.enum new_edges_list) !analysis_ref
    in
    let ddpa_logging_data' =
      match analysis'.ddpa_logging_data with
      | None -> None
      | Some data ->
        Some { data with ddpa_closure_steps = data.ddpa_closure_steps+1 }
    in
    let result =
      { analysis' with
        ddpa_graph_fully_closed = not any_new;
        ddpa_logging_data = ddpa_logging_data'
      }
    in
    begin
      match result.ddpa_logging_data with
      | None -> logger `trace "Completed closure step"
      | Some data -> lazy_logger `trace
                       (fun () -> Printf.sprintf "Completed closure step %d"
                           (data.ddpa_closure_steps));
    end;
    log_cfg Log_everything result;
    result
  ;;

  let is_fully_closed analysis = analysis.ddpa_graph_fully_closed;;

  let rec perform_full_closure analysis =
    if is_fully_closed analysis
    then
      begin
        logger `trace "Closure complete.";
        log_pdr Log_result analysis.ddpa_logging_data analysis.pds_reachability;
        log_cfg Log_result analysis;
        analysis
      end
    else
      begin
        perform_full_closure @@ perform_closure_steps analysis
      end
  ;;
end;;
