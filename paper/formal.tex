\section{Intro}

In this section, we will first provide the model theory definition of types in 
our language. However, since in real programs, we cannot effectively perform 
certain mathematical enumerations (such as enumeration of functions), we will 
need an operational-semantics-based definition of how typechecking works in actual 
programs. As such, we will provide a proof theory definition of types, and prove
equivalence of the two systems.

\section{Core Language}

First, we'll define a small core language with basic integers, booleans, binary 
operations, conditionals, and functions.

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \ev
                \gor \gtfun\ \ev \gtarrow \expr
                \gor \expr\ \expr
                \gline
                \gor \expr\ \binop\ \expr
                \gor \ife{\expr}{\expr}{\expr}
                \gor \letin{\ev}{\expr}{\expr}
                \gline 
                \gor \pick_i 
                \gor \pick_b
                \gor \eerror
            }
            \grule[variables]{\ev}{
                        \textit{(identifiers)}
            }
            \grule[values]{\eval}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \gtfun\ \ev \gtarrow \expr
            }
            \grule[types]{\syntype}{
              \tint
              \gor \tbool
              \gor \tfun
          }
        \end{grammar}
    \caption{Core language grammar}
    \label{fig_Grammar}
\end{figure}

\subsection{Modeling Types}

The typing rules of the system is defined as following:

\begin{definition}[Typing rules in model theory]
  \label{def_typingM}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\tint}$ iff $\forall \eval. \expr \smallsteps[] \eval$, $\eval \in \mathbb{Z}$.
      \item $\ \models \hastype{\expr}{\tbool}$ iff $\forall \eval.\expr \smallsteps[] \eval$, $\eval \in \mathbb{B}$.
      \item $\ \models \hastype{\expr}{\mkfun{\syntype_1}{\syntype_2}}$ iff $\forall \eval_f.\expr \smallsteps[] \eval_f$, and that $\forall{\eval}.$ if $\models \hastype{\eval}{\syntype_1}$, then $\models \hastype{\eval_f\ \eval}{\syntype_2}$.
   \end{enumerate}
\end{definition}

Note that the rules do not actually check the types of the subexpressions. In 
fact, we can have an expression such as \texttt{Y}\ 
\texttt{(fun this -> fun n -> if n = 0 then 0 else this (n-1))} and 
assign the type \texttt{int -> int} to it, in spite of the fact that
we cannot assign types to any of its subexpressions.

\subsection{Proving Types}

In this section, we will provide the proof theory definition of typechecking.

\begin{definition}[Type Generator]
  \label{def_genCore}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkgen{\tint} = \pick_i$
    \item $\mkgen{\tbool} = \pick_b$
    \item $\mkgen{\mkfun{\syntype_1}{\syntype_2}} = \mkfunv{\ev}{\letin{\_}{\mkche{\syntype_1}{\ev}}{\mkgen{\syntype_2}}}$
  \end{enumerate}
\end{definition}

\begin{definition}[Type Checker]
  \label{def_checkCore}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\mkche{\tint}{\expr} = \ife{\matches{\expr}{\tint}}{\expr}{\eerror}$
      \item $\mkche{\tint}{\expr} = \ife{\matches{\expr}{\tbool}}{\expr}{\eerror}$
      \item $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\expr} = \\
       \texttt{let arg = }\mkgen{\syntype_1} \texttt{ in }\mkche{\syntype_2}{\texttt{(e arg)}}$
   \end{enumerate}
\end{definition}

\begin{definition}[Typing rules in proof theory]
  \ \par
  $\ \vdash \hastype{\expr}{\syntype}$ iff $\forall\eval.$ if $\expr \smallsteps[] \eval$, then $\mkche{\syntype}{\eval} \nsmallsteps[] \eerror$.
\end{definition}

\subsection{Completeness and Soundness}

In this section, we will show that the two definitions are equivalent, by showing
completeness and soundness.

\begin{proof}[Completeness]
  $\forall. \expr$ if $\not\vdash \hastype{\expr}{\syntype}$, then $\not\models \hastype{\expr}{\syntype}$.

  This is equivalent to showing: if $\exists \eval. \expr \smallsteps[] \eval$ and $\mkche{\syntype}{\eval} \smallsteps[] \eerror$, then $\not\models \hastype{\expr}{\syntype}$.

  To prove this statement, we'll need the following lemma:

  \begin{lemma}
    $\models \hastype{\mkgen{\syntype}}{\syntype}$.
  \end{lemma}

  We will prove these two statements at the same time by mutual induction on the structure of $\syntype$.

  \textbf{Base case}: $\syntype = \tint$

  Since $\mkgen{\tint} = pick_i$, by definition of $\pick_i$, we know that $\forall \eval.$ if $\pick_i \smallsteps[] \eval$, then $\eval \in \mathbb{Z}$. Thus, we have shown that $\hastype{\mkgen{\tint}}{\tint}$.

  Given $\exists \eval. \expr \smallsteps[] \eval$ and $\mkche{\tint}{\expr} \smallsteps[] \eerror$, we know that there are two potential sources for $\eerror$:
  \begin{enumerate}
    \item $\expr \smallsteps[] \eerror$. In this case, $\not\models \hastype{\expr}{\tint}$ is trivial. 
    \item $\expr \smallsteps[] \eval$. In this case, we know that $\matches{\eval}{\tint} \smallsteps[] \texttt{false}$, which means $\eval \notin \mathbb{Z}$. Thus $\not\models \hastype{\expr}{\tint}$. 
  \end{enumerate}

  Proof for the case where $\syntype = \tbool$ is very similar, so we'll omit it here for brevity.

  \textbf{Inductive step:} $\syntype = \mkfun{\syntype_1}{\syntype_2}$

  Since $\mkgen{\mkfun{\syntype_1}{\syntype_2}} = \mkfunv{\ev}{\letin{\_}{\mkche{\syntype_1}{\ev}}{\mkgen{\syntype_2}}}$, by inductive hypothesis, we know that $\forall.\expr$ if $\models \hastype{\expr}{\syntype_1}$, then $\vdash \hastype{\expr}{\syntype_1}$, which means $\mkche{\syntype_1}{\expr} \nsmallsteps[] \eerror$. By the definition of $\mkgen{\syntype}$, we also know that $\mkgen{\syntype} \nsmallsteps[] \eerror$.
  
  Therefore, we can conclude that $\forall \eval.$ if $\models \hastype{\eval}{\syntype_1}$, then $(\mkgen{\mkfun{\syntype_1}{\syntype_2}}\
   \eval) \smallsteps[] \mkgen{\syntype_2}$. By inductive hypothesis, we know that $\hastype{\mkgen{\syntype_2}}{\syntype_2}$. Therefore, we have shown that $\hastype{\mkgen{\mkfun{\syntype_1}{\syntype_2}}}{\mkfun{\syntype_1}{\syntype_2}}$.

   Given $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\expr} \smallsteps[] \eerror$, since $\texttt{arg} = \mkgen{\syntype}$ is guaranteed to evaluate to a value, we know that $\eerror$ must come from $\mkche{\syntype_2}{\texttt{(e arg)}}$. This suggests that $\exists \eval. \texttt{(e arg)} \smallsteps[] \eval$ and $\not\vdash \hastype{\eval}{\syntype_2}$. By induction hypothesis, we know that $\not\models \hastype{\texttt{\eval}}{\syntype_2}$, and that $\models \hastype{\mkgen{\syntype_1}}{\syntype_1}$. Thus we have found a witness $\models \hastype{\eval}{\syntype_1}$ such that $\not\models \hastype{(\expr \ \eval)}{\syntype_2}$, proving that $\not\models \hastype{\expr}{\mkfun{\syntype_1}{\syntype_2}}$.

\end{proof}

\begin{proof}[Soundness]
  $\forall. \expr$ if $\not\models \hastype{\expr}{\syntype}$, then $\not\vdash \hastype{\expr}{\syntype}$.

  This is equivalent to showing: if $\not\models \hastype{\expr}{\syntype}$, then $\exists \eval. \expr \smallsteps[] \eval$ and $\mkche{\syntype}{\eval} \smallsteps[] \eerror$.

\end{proof}

\section{Language extensions}

Next, we will define a couple of languages extensions and their corresponding typing rules.

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
              \cdots
              \gor \vpoly
            }
            \grule[values]{\eval}{
              \cdots
              \gor \vpoly
            }
            \grule[types]{\syntype}{
              \cdots
              \gor \tpoly
              \gor \mkunion{\syntype}{\syntype}
              \gor \mkintersect{\syntype}{\syntype}
              \gor \mktset{\syntype}{\expr}
              \gor \mkdfun{\ev}{\syntype}{\syntype}
              \gor \mkmiu{\alpha}{\syntype}
          }
        \end{grammar}
    \caption{Extended language grammar}
    \label{ext_Grammar}
\end{figure}

\begin{definition}[More typing rules]
  \label{def_typingRulesExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\tpoly}$ iff $\expr \bigstep \vpoly$, where $\textsc{typeof}(\vpoly) = \tpoly$.
      \item $\ \models \hastype{\expr}{\mkunion{\syntype_1}{\syntype_2}}$ iff $\ \models \hastype{\expr}{\syntype_1}$ or $\ \models \hastype{\expr}{\syntype_2}$.
      \item $\ \models \hastype{\expr}{\mkintersect{\syntype_1}{\syntype_2}}$ iff $\ \models \hastype{\expr}{\syntype_1}$ and $\ \models \hastype{\expr}{\syntype_2}$.
      \item $\ \models \hastype{\expr}{\mktset{\syntype}{p}}$ iff $\ \models \hastype{\expr}{\syntype}$ and $p \ \expr \Longrightarrow \gttrue$.
      \item $\ \models \hastype{\expr}{\mkdfun{\ev}{\syntype_1}{\syntype_2}}$ iff $\forall{\eval}$ such that $\models \hastype{\eval}{\syntype_1}$, $\models \hastype{\expr\ \eval}{\substitute{\syntype_2}{\eval}{\ev}}$.
      \item $\ \models \hastype{\expr}{\mkmiu{\alpha}{\syntype}}$ iff ?.
  \end{enumerate}
\end{definition}

We will now extend the language with records.


\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
              \cdots
              \gor \{\overline{\elbl = \expr}\}^{\{\overline{\elbl}\}}
              \gor \expr.\elbl
            }
            \grule[values]{\eval}{
              \cdots
              \gor \{\overline{\elbl = \eval}\}^{\{\overline{\elbl}\}}
            }
            \grule[types]{\syntype}{
              \cdots
              \gor \{\overline{\hastype{\elbl}{\syntype}}\} 
          }
        \end{grammar}
    \caption{Extended language grammar (with records)}
    \label{rec_Grammar}
\end{figure}

\begin{definition}[Record typing rules]
  \label{def_typingRec}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\{\hastype{\elbl_1}{\syntype_1},\ \cdots, \hastype{\elbl_m}{\syntype_m}\}}$ iff $\expr \bigstep \{\elbl_1 = \eval_1,\ \cdots, \elbl_m = \eval_m,\ \cdots, \elbl_n = \eval_n\}^{\{\elbl_1, \cdots, \elbl_p\}}$ where $\ \models \hastype{\eval_i}{\syntype_i}$ for $i \in \{1,\ \cdots, m\}$, $n \geq p \geq m$.
  \end{enumerate}
\end{definition}

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \ev
                \gor \gtfun\ \ev \gtarrow \expr
                \gor \expr\ \expr
                \gor \expr \ \binop \ \expr
                \gor \vpoly
                \gor \{\overline{\elbl = \expr}\}^{\{\overline{\elbl}\}}
                \gor \expr.\elbl
                \gline
                \gor \ife{\expr}{\expr}{\expr}
                \gor \pick_i
                \gor \pick_b
                \gor \mzero
                \gor \eerror
                \gline
                \gor \letin{\ev}{\expr}{\expr}
                \gor \letfun
                \gor \matches{\expr}{p}
            }
            \grule[variables]{\ev}{
                \textit{(identifiers)}
            }
            \grule[patterns]{p}{
                \tint
                \gor \tbool
                \gor \gtfun
                \gor \gtany
                \gor \vpoly
                \gor \{\overline{\elbl}\}
            }
            \grule[values]{\eval}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \gtfun\ \ev \gtarrow \expr
                \gor \ev
                \gor \vpoly
                \gor \{\overline{\elbl = \eval}\}^{\{\overline{\elbl}\}}
            }
            \grule[types]{\syntype}{
                \tint
                \gor \tbool
                \gor \tfun
                \gor \tpoly
                \gor \mkunion{\syntype}{\syntype}
                \gor \mkintersect{\syntype}{\syntype}
                \gor \mktset{\syntype}{\expr}
                \gor \mkdfun{\ev}{\syntype}{\syntype}
                \gor \mkmiu{\alpha}{\syntype}
                \gor \{\overline{\hastype{\elbl}{\syntype}}\}
          }
        \end{grammar}
    \caption{Complete language grammar}
    \label{fig_completeGrammar}
\end{figure}

\section{Type as values}

In this section, we will demonstrate how to represent each type using a tuple of functions $\genf$ and $\chef$.

\begin{definition}[Semantic interpretation of types]
  \label{def_typeAsVal}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  We define the semantic interpretation of types as $\llbracket \syntype \rrbracket = \{\texttt{gen = \mkgen{\syntype}, check = }\mkfunv{\expr}{\mkche{\syntype}{\expr}}\}$.
\end{definition}

% \begin{definition}[Defining Generator in the core language]
%   \label{def_genCore}
%   % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
%   \ \par 
%   \begin{enumerate}
%     \item $\mkgen{\tint} : \pick_i$.
%     \item $\mkgen{\tbool} : \pick_b$.
%     \item $\mkgen{\mkfun{\syntype_1}{\syntype_2}} : \mkfunv{\ev}{\mkgen{\syntype_2}}$.
%   \end{enumerate}
% \end{definition}

% \begin{definition}[Defining Checker in the core language]
%   \label{def_CheCore}
%   % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
%   \ \par 
%   \begin{enumerate}
%     \item $\mkche{\tint}{\expr} : \matches{\expr}{\tint}$.
%     \item $\mkche{\tbool}{\expr} : \matches{\expr}{\tbool}$.
%     \item $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\expr} : \texttt{let arg = }\mkgen{\syntype_1} \texttt{ in }\mkche{\syntype_2}{\texttt{(e arg)}}$.
%   \end{enumerate}
% \end{definition}

\begin{definition}[Defining Generator in the extended language]
  \label{def_genExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkgen{\tpoly_i} : \vpoly_i$.
    \item $\mkgen{\mkunion{\syntype_1}{\syntype_2}} : \pick_b$. $\ife{b}{\mkgen{\syntype_1}}{\mkgen{\syntype_2}}$.
    \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where $\syntype_1, \syntype_2$ are not arrow types or record types : $\pick \ b \in \mathbb{B}$. \\ 
    $\texttt{if }b\texttt{ then }$
    $\\\texttt{\ \ let gend = }\mkgen{\syntype_1}\texttt{ in }$
    $\\ \texttt{\ \ if }\mkche{\syntype_2}{\texttt{gend}}\texttt{ then gend else } \mzero$
    $\\ \texttt{else}$
    $\\\texttt{\ \ let gend = }\mkgen{\syntype_2}\texttt{ in }$
    $\\ \texttt{\ \ if }\mkche{\syntype_1}{\texttt{gend}}\texttt{ then gend else } \mzero$   
    \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where $\syntype_1 = \mkfun{\syntype_{dom1}}{\syntype_{cod1}}, \syntype_2 = \mkfun{\syntype_{dom2}}{\syntype_{cod2}} : $ \\ $\mkfunv{\ev}{\\
      \texttt{\ \ }\ife{\mkche{\syntype_{dom1}}{\ev}}{\mkgen{\syntype_{cod1}}}{\mkgen{\syntype_{cod2}}}
    }$. 
    \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where \\ 
    $\syntype_1 = \{\hastype{\elbl_1}{\syntype_1'}, \cdots, \hastype{\elbl_n}{\syntype_n'}, \cdots, \hastype{\elbl_{11}}{\syntype_{11}'}, \cdots, \hastype{\elbl_{1m}}{\syntype_{1m}'}\}, 
    \\ \syntype_2 = \{\hastype{\elbl_1}{\syntype_1''}, \cdots, \hastype{\elbl_n}{\syntype_n''}, \cdots, \hastype{\elbl_{21}}{\syntype_{21}''}, \cdots, \hastype{\elbl_{2n}}{\syntype_{2n}''}\} : $ \\ 
    $\{\elbl_1 = \mkgen{\mkintersect{\syntype_1'}{\syntype_1''}}, \cdots, \elbl_n = \mkgen{\mkintersect{\syntype_n'}{\syntype_n''}}, \cdots, \elbl_{11} = \syntype_{11}, \cdots, \elbl_{2n} = \syntype_{2n}'\}$. 
    \item $\mkgen{\mktset{\syntype}{p}} : $ \\ 
    $\texttt{let gend = }\mkgen{\syntype} \texttt{ in } \ife{\texttt{(p gend)}}{\texttt{gend}}{\mzero}.$
    \item $\mkgen{\mkdfun{\ev}{\syntype_1}{\syntype_2}} : $
    \\$\mkfunv{\ev'}{\ife{\mkche{\tau_1}{\ev'}}{\mkgen{\substitute{\syntype_2}{\ev'}{\ev}}}{\eerror}}.$
    \item $\mkgen{\mkmiu{\alpha}{\syntype}} : \mkgen{\substitute{\syntype}{\alpha}{\mkmiu{\alpha}{\syntype}}}.$
    \item $\mkgen{\{\hastype{\elbl_1}{\syntype_1}, \cdots, \hastype{\elbl_n}{\syntype_n}\}} :$ \\ $\texttt{let }\eval_1 = \mkgen{\syntype_1}\texttt{ in }\cdots\texttt{ let }\eval_n = \mkgen{\syntype_n}\texttt{ in } \{\elbl_1 = \eval_1, \cdots, \elbl_n = \eval_n\}.$
  \end{enumerate}
\end{definition}

\begin{definition}[Defining Checker in the extended language]
  \label{def_cheExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkche{\tpoly_i}{\expr} : \matches{\expr}{\vpoly_i}$.
    \item $\mkche{\mkunion{\syntype_1}{\syntype_2}}{\expr} : \mkche{\syntype_1}{\expr} \texttt{ or } \mkche{\syntype_2}{\expr}$.
    \item $\mkche{\mkintersect{\syntype_1}{\syntype_2}}{\expr} : \mkche{\syntype_1}{\expr} \texttt{ and } \mkche{\syntype_2}{\expr}$. 
    \item $\mkche{\mktset{\syntype}{p}}{\expr} : \mkche{\syntype}{\expr} \texttt{ and } \evaluate{\expr} = \gttrue$.
    \item $\mkche{\mkdfun{\ev}{\syntype_1}{\syntype_2}}{\expr} : \texttt{let arg = } \mkgen{\syntype_1} \texttt{ in } \mkche{\substitute{\syntype_2}{\texttt{arg}}{\ev}}{\texttt{(e arg)}}$.
    \item $\mkche{\mkmiu{\alpha}{\syntype}}{\expr} : \mkche{\substitute{\syntype}{\mkmiu{\alpha}{\syntype}}{\alpha}}{\expr}$.
    \item $\mkche{\{\hastype{\elbl_1}{\syntype_1}, \cdots, \hastype{\elbl_m}{\syntype_m}\}}{\expr} :$
    $\evaluate{\expr} = \{\elbl_1 = \eval_1, \cdots, \elbl_m = \eval_m, \cdots, \elbl_n = \eval_n\}^{\{\elbl_1, \cdots, \elbl_m\}}$ \\ 
    $\texttt{and } \mkche{\syntype_1}{\eval_1} \cdots \texttt{ and } \mkche{\syntype_m}{\eval_m}$.
  \end{enumerate}
\end{definition}

\section{Selective typechecking}

We allow users to declare types in their program selectively. If an expression doesn't have a type declaration, we assume that the user does not wish for us to check its type. In other words, we will only be checking explicitly declared types in the user program.

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
                \cdots
                \gor \letfunt
                \gor \letint{\ev}{\syntype}{\expr}{\expr}
            }
        \end{grammar}
    \caption{Updated language grammar}
    \label{fig_updatedGrammar}
\end{figure}

