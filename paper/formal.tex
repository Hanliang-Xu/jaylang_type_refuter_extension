\section{Intro}

In this section, we will first provide the model theory definition of types in 
our language. However, since in real programs, we cannot effectively perform 
certain mathematical enumerations (such as enumeration of functions), we will 
need an operational-semantics-based definition of how typechecking works in actual 
programs. As such, we will provide a proof theory definition of types, and prove
equivalence of the two systems.

\section{Core Language}

First, we'll define a small core language with basic integers, booleans, binary 
operations, conditionals, and functions.

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \ev
                \gor \gtfun\ \ev \gtarrow \expr
                \gor \expr\ \expr
                \gline
                \gor \expr\ \binop\ \expr
                \gor \ife{\expr}{\expr}{\expr}
                \gor \letin{\ev}{\expr}{\expr}
                \gline 
                \gor \matches{\expr}{p}
                \gor \pick_i 
                \gor \pick_b
                \gor \eerror
            }
            \grule[variables]{\ev}{
                        \textit{(identifiers)}
            }
            \grule[patterns]{p}{
              \tint
              \gor \tbool
              \gor \gtfun
            }
            \grule[values]{\eval}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \gtfun\ \ev \gtarrow \expr
            }
            \grule[types]{\syntype}{
              \tint
              \gor \tbool
              \gor \tfun
          }
        \end{grammar}
    \caption{Core language grammar}
    \label{fig_Grammar}
\end{figure}

\subsection{Modeling Types Mathematically}

The typing rules of the system is defined as following:

\begin{definition}[Typing rules]
  \label{def_typingM}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\tint}$ iff $\expr \nsmallsteps[] \eerror$ and $\forall \eval. \expr \smallsteps[] \eval$, $\eval \in \mathbb{Z}$.
      \item $\ \models \hastype{\expr}{\tbool}$ iff $\expr \nsmallsteps[] \eerror$ and $\forall \eval.\expr \smallsteps[] \eval$, $\eval \in \mathbb{B}$.
      \item $\ \models \hastype{\expr}{\mkfun{\syntype_1}{\syntype_2}}$ iff $\expr \nsmallsteps[] \eerror$ and $\forall \eval_f.$ if $\expr \smallsteps[] \eval_f$, \\ then $\forall{\eval}.$ if $\models \hastype{\eval}{\syntype_1}$, then $\models \hastype{\eval_f\ \eval}{\syntype_2}$.
   \end{enumerate}
\end{definition}

Note that the rules do not actually check the types of the subexpressions. In 
fact, we can have an expression such as \texttt{Y}\ 
\texttt{(fun this -> fun n -> if n = 0 then 0 else this (n-1))} and 
assign the type \texttt{int -> int} to it, in spite of the fact that
we cannot assign types to any of its subexpressions.

\subsection{Modeling Types Practically}

In this section, we will provide the proof theory definition of typechecking.

\begin{definition}[Type Generator]
  \label{def_genCore}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkgen{\tint} = \pick_i$
    \item $\mkgen{\tbool} = \pick_b$
    \item $\mkgen{\mkfun{\syntype_1}{\syntype_2}} = \mkfunv{\ev}{\letin{\_}{\mkche{\syntype_1}{\ev}}{\mkgen{\syntype_2}}}$
  \end{enumerate}
\end{definition}

\begin{definition}[Type Checker]
  \label{def_checkCore}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\mkche{\tint}{\expr} = \ife{\matches{\expr}{\tint}}{\expr}{\eerror}$
      \item $\mkche{\tbool}{\expr} = \ife{\matches{\expr}{\tbool}}{\expr}{\eerror}$
      \item $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\expr} = \\
       \texttt{let arg = }\mkgen{\syntype_1} \texttt{ in }\letin{\_}{\mkche{\syntype_2}{\texttt{(e arg)}}}{\texttt{e}}$
   \end{enumerate}
\end{definition}

\begin{definition}[Updated typing rule]
  \ \par
  $\models_p \hastype{\expr}{\syntype}$ iff $\mkche{\syntype}{\expr} \nsmallsteps[] \eerror$.
\end{definition}

\subsection{Completeness and Soundness}

In this section, we will show that the two definitions are equivalent.

\begin{theorem}
  $\forall \expr.$ $\not\models_p \hastype{\expr}{\syntype}$ iff $\not\models \hastype{\expr}{\syntype}$.
\end{theorem}

\begin{proof}[Completeness]
  $\forall \expr.$ if $\not\models_p \hastype{\expr}{\syntype}$, then $\not\models \hastype{\expr}{\syntype}$.

  This is equivalent to showing: if $\mkche{\syntype}{\expr} \smallsteps[] \eerror$, then $\not\models \hastype{\expr}{\syntype}$.

  To prove this statement, we'll need the following lemma:

  \begin{lemma}
    $\models \hastype{\mkgen{\syntype}}{\syntype}$.
  \end{lemma}

  We will prove the conjunction of the completeness statement and the lemma by induction on the structure of $\syntype$.

  \textbf{Base case}: $\syntype = \tint$

  First, we will show that $\models \hastype{\mkgen{\tint}}{\tint}$.
  
  Since $\mkgen{\tint} = pick_i$, by definition of $\pick_i$, we know that $\forall \eval.$ if $\pick_i \smallsteps[] \eval$, then $\eval \in \mathbb{Z}$. Thus, we have shown that $\models \hastype{\mkgen{\tint}}{\tint}$.

  Next, we'll prove that for an arbitrary $\expr$, if $ \hastype{\expr}{\tint}$, then $\not\models \hastype{\expr}{\tint}$.

  By definition of $\vdash \hastype{\expr}{\tint}$, we know that $\not\models_p \hastype{\expr}{\tint}$ suggests $\mkche{\tint}{\expr} \smallsteps[] \eerror$. Examining the definition of $\mkche{\tint}{\expr}$, we can see that there are two potential sources for $\eerror$:
  \begin{enumerate}
    \item $\expr \smallsteps[] \eerror$. In this case, $\not\models \hastype{\expr}{\tint}$ is trivial. 
    \item $\expr \smallsteps[] \eval$. In this case, we know that $\matches{\eval}{\tint} \smallsteps[] \texttt{false}$, which means $\eval \notin \mathbb{Z}$. Thus $\not\models \hastype{\expr}{\tint}$. 
  \end{enumerate}

  Proof for the case where $\syntype = \tbool$ is very similar, so we'll omit it here for brevity.

  \textbf{Inductive step:} $\syntype = \mkfun{\syntype_1}{\syntype_2}$

  First, we will show that $\models \hastype{\mkgen{\mkfun{\syntype_1}{\syntype_2}}}{\mkfun{\syntype_1}{\syntype_2}}$.

  To prove this, we need to show that $\forall\eval.$ if $\hastype{\eval}{\syntype_1}$, then $\models \hastype{(\mkgen{\mkfun{\syntype_1}{\syntype_2}} \ \eval)}{\syntype_2}$.
  
  By definition, $(\mkgen{\mkfun{\syntype_1}{\syntype_2}}) \ \eval = \letin{\_}{\mkche{\syntype_1}{\eval}}{\mkgen{\syntype_2}}$.

  By inductive hypothesis, $\forall\eval.$ if $\models \hastype{\eval}{\syntype_1}$, then $\vdash \hastype{\eval}{\syntype_1}$, which means $\mkche{\syntype_1}{\eval}\nsmallsteps[] \eerror$. In the case that $\mkche{\syntype_1}{\eval}$ diverges, $(\mkgen{\mkfun{\syntype_1}{\syntype_2}}) \ \eval$ will diverge, too, making the statement $\models \hastype{(\mkgen{\mkfun{\syntype_1}{\syntype_2}} \ \eval)}{\syntype_2}$ trivially true. If $\mkche{\syntype_1}{\eval}$ doesn't diverge, we only have to consider $\mkgen{\syntype_2}$. By inductive hypothesis, we know that $\models \hastype{\mkgen{\syntype_2}}{\syntype_2}$. Therefore, we have shown that $\forall\eval.$ if $\hastype{\eval}{\syntype_1}$, then $\models \hastype{(\mkgen{\mkfun{\syntype_1}{\syntype_2}} \ \eval)}{\syntype_2}$, which means $\models \hastype{\mkgen{\mkfun{\syntype_1}{\syntype_2}}}{\mkfun{\syntype_1}{\syntype_2}}$.

  Next, we'll prove that for an arbitrary $\expr$, if $\not\models_p \hastype{\expr}{\mkfun{\syntype_1}{\syntype_2}}$, then $\not\models \hastype{\expr}{\mkfun{\syntype_1}{\syntype_2}}$.

  By definition, $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\expr} = \texttt{let arg = }\mkgen{\syntype_1} \texttt{ in }\mkche{\syntype_2}{\texttt{(e arg)}}$. Since $\mkgen{\syntype_1}$ is guaranteed to evaluate to a value, we know that $\eerror$ must come from $\mkche{\syntype_2}{\texttt{(e arg)}}$. This suggests that $\not\models_p \hastype{(\expr\ \texttt{arg})}{\syntype_2}$. By induction hypothesis, we know that $\not\models \hastype{(\texttt{\expr\ \texttt{arg}})}{\syntype_2}$, and that $\models \hastype{\mkgen{\syntype_1}}{\syntype_1}$. Thus we have found a witness $\models \hastype{\texttt{arg}}{\syntype_1}$ such that $\not\models \hastype{(\expr \ \texttt{arg})}{\syntype_2}$, proving that $\not\models \hastype{\expr}{\mkfun{\syntype_1}{\syntype_2}}$.

\end{proof}

\begin{proof}[Soundness]
  $\forall. \expr$ if $\not\models \hastype{\expr}{\syntype}$, then $\not\models_p \hastype{\expr}{\syntype}$.

  This is equivalent to showing: if $\not\models \hastype{\expr}{\syntype}$, then $\mkche{\syntype}{\expr} \smallsteps[] \eerror$. Since we know that $\not \models \hastype{\expr}{\syntype}$, we can conclude that $\expr \not\Uparrow$. 

  Consider the case where $\expr \smallsteps[] \eerror$. By the operational semantics, we know that if $\expr$ evaluates to $\eerror$, then $\mkche{\syntype}{\expr} \smallsteps[] \eerror$.

  Now, we have to show that if $\expr \smallsteps[] \eval$, and that $\not \models \hastype{\eval}{\syntype}$, then $\not\models_p \hastype{\expr}{\syntype}$. We will prove this by induction on the size of $\syntype$.

  \textbf{Base case: }$\syntype = \tint$

  Given $\not \models \hastype{\expr}{\tint}$ and $\expr \smallsteps[] \eval$, we know that $\eval \not\in \mathbb{Z}$. Unpack the definition for $\mkche{\tint}{\expr}$, we get $\ife{\matches{\expr}{\tint}}{\expr}{\eerror}$. Since $\expr \smallsteps[] \eval$ and $\eval \not\in \mathbb{Z}$, $\matches{\expr}{\tint}$ will evaluate to $\gtfalse$, and the entire $\texttt{if}$ expression will evaluate to $\eerror$.

  Proof for the case where $\syntype = \tbool$ is very similar, so we'll omit it here for brevity.

  \textbf{Inductive step: }$\syntype = \mkfun{\syntype_1}{\syntype_2}$

  To prove the case for function types, we need the following auxilliary definition.

  \begin{definition}
    $\expr_1 \subseteq_{\syntype} \expr_2$ is defined as the following by case analysis:

    $\expr_1 \subseteq_{\tint} \expr_2$ iff $\forall \eval_1.$ if $\expr_1 \smallsteps[] \eval_1$, then $\expr_2 \smallsteps[] \eval_1$, $\eval_1 \in \mathbb{Z}$.

    $\expr_1 \subseteq_{\tbool} \expr_2$ iff $\forall \eval_1.$ if $\expr_1 \smallsteps[] \eval_1$, then $\expr_2 \smallsteps[] \eval_1$, $\eval_1 \in \mathbb{B}$.

    $\expr_1 \subseteq_{\mkfun{\syntype_1}{\syntype_2}} \expr_2$ iff $\forall \eval_1.$ if $\expr_1 \smallsteps[] \eval_1$, then $\exists \eval_2. \expr_2 \smallsteps[] \eval_2$, $\models \hastype{\eval_1, \eval_2}{\mkfun{\syntype_1}{\syntype_2}}$, and $\forall \eval, \eval_{r1}.$ if $\models \hastype{\eval}{\syntype_1}$ and $(\eval_1 \ \eval) \smallsteps[] \eval_{r1}$, then $\exists \eval_{r2}. (\eval_2 \ \eval) \smallsteps[] \eval_{r2}$ and $\eval_{r1} \subseteq_{\syntype_2} \eval_{r2}$; if $\not\models \hastype{\eval}{\syntype_1}$, then $\eval_2 \ \eval \smallsteps[] \eerror$.

  \end{definition}

  We will also need the following lemmas:

  \begin{lemma}
    If $\models \hastype{\eval}{\syntype}$, then $\eval \subseteq_{\syntype} \mkgen{\syntype}$.
  \end{lemma}

  \begin{proof}
    We will prove Lemma 2.8 by induction on the size of $\syntype$.

    \textbf{Base case: }$\syntype = \tint$

    Since $\mkgen{\tint} = \pick_i$, by definition of $\pick_i$, we know that $\pick_i \smallstep[] \eval$.

    Proof for the case where $\syntype = \tbool$ is very similar, so we'll omit it here for brevity.

    \textbf{Inductive step: }$\syntype = \mkfun{\syntype_1}{\syntype_2}$

    % By definition, $\mkgen{\mkfun{\syntype_1}{\syntype_2}} = \mkfunv{\ev}{\letin{\_}{\mkche{\syntype_1}{\ev}}{\mkgen{\syntype_2}}}$. 
    By Lemma 2.6, we know that $\models \hastype{\mkgen{\mkfun{\syntype_1}{\syntype_2}}}{\mkfun{\syntype_1}{\syntype_2}}$. 
    
    Then, we'll show that $\forall \eval_0. $ if $\models \hastype{\eval_0}{\syntype_1}$ and $\eval \ \eval_0 \smallsteps[] \eval_{r1}$, then $(\mkgen{\mkfun{\syntype_1}{\syntype_2}}) \ \eval_0 \smallsteps[] \eval_{r2}$ and $\eval_{r1} \subseteq_{\syntype_2} \eval_{r2}$.

    By definition, $(\mkgen{\mkfun{\syntype_1}{\syntype_2}}) \ \eval_0 = \letin{\_}{\mkche{\syntype_1}{\eval_0}}{\mkgen{\syntype_2}}$. By completeness, we know that $\mkche{\syntype_1}{\eval_0} \nsmallsteps[] \eerror$. Moreover, since we're given that $\eval \ \eval_0 \smallsteps[] \eval_{r1}$, which indicates that $\eval_0 \not\Uparrow$, we can conclude that $(\mkgen{\mkfun{\syntype_1}{\syntype_2}}) \ \eval_0 \smallsteps[] \mkgen{\syntype_2}$. By Lemma 2.6, we know that $\models \hastype{\mkgen{\syntype_2}}{\syntype_2}$. By inductive hypothesis, we know that $\eval_{r1} \subseteq_{\syntype_2} \mkgen{\syntype_2}$.

    Finally, we need to show that $\forall \eval_0. $ if $\not \models \hastype{\eval_0}{\syntype_1}$, then $(\mkgen{\mkfun{\syntype_1}{\syntype_2}}) \ \eval_0 \smallsteps[] \eerror$. 
    
    By definition, $(\mkgen{\mkfun{\syntype_1}{\syntype_2}}) \ \eval_0 = \letin{\_}{\mkche{\syntype_1}{\eval_0}}{\mkgen{\syntype_2}}$. By induction hypothesis, we know that if $\not \models \hastype{\eval_0}{\syntype_1}$, then ${\mkche{\syntype_1}{\eval_0}} \smallsteps[] \eerror$. Therefore, we know that the application expression itself also evalutes to $\eerror$.
  \end{proof}

  \begin{lemma}
    $\forall \eval.$ if $\models \hastype{\eval}{\syntype}$ and $\eval \subseteq_{\syntype} \eval'$, then $\forall C.$ if $\not \models \hastype{C[\eval]}{\syntype_0}$, then $\not \models \hastype{C[v']}{\syntype_0}$. 
  \end{lemma}

  \begin{proof}
    We will prove Lemma 2.9 by induction on the size of $\syntype$.

    \textbf{Base case: }$\syntype = \tint$

    By definition of $\subseteq_{\tint}$, we know that $\eval = \eval'$, therefore $C[v] = C[v']$. It naturally follows that $\not \models \hastype{C[v']}{\syntype_0}$.

    Proof for the case where $\syntype = \tbool$ is very similar, so we'll omit it here for brevity.

    \textbf{Inductive step: }$\syntype = \mkfun{\syntype_1}{\syntype_2}$

    Given that $\not \models \hastype{C[\eval]}{\syntype_0}$, there are two scenarios we need to consider:
    \begin{enumerate}
      \item $C[\eval] \smallsteps[] \eerror$,
      \item $C[\eval] \smallsteps[] \eval_{r1}$ and $\not \models \hastype{\eval_{r1}}{\syntype_0}$.
    \end{enumerate}

    The proof for these two cases are very similar, so we will only go over the proof for $C[\eval] \smallsteps[] \eerror$. We will prove this by induction on the length of $C[\eval] \smallsteps[] \eerror$.

    \textbf{Base case: }$C[\eval] \smallstep[] \eerror$
    
    If $C$ doesn't have holes, the statement will be trivially true for $\eval$ and $\eval'$. We will only consider the case where $C$ indeed contains holes to be filled by $\eval$ and $\eval'$ respectively.
    In this case, $C[\eval]$ can only be one of the following three:

    \begin{enumerate}
      \item $\eval_1 + \eval_2$ where $\eval_1 = \eval$ or $\eval_2 = \eval$ (or both): In the first case, $C[\eval'] = \eval' + \eval_2$, and the other two cases follow similarly. According to the operational semantics, addition where one of the operands is a non-integer will evaluate to $\eerror$. Therefore, since $\eval$ and $\eval'$ are both function values, we know that $C[\eval'] \smallstep[] \eerror$.
      \item $\eval_1 \ \eval$ where $\eval_1$ isn't a function value: In this case, $C[\eval'] = \eval_1 \ \eval'$. Again, by operational semantics, application of non-function will evaluate to $\eerror$, which means $C[\eval'] \smallstep[] \eerror$.
      \item $\ife{\eval}{\expr_1}{\expr_2}$: In this case, $C[\eval'] = \ife{\eval'}{\expr_1}{\expr_2}$. Both cases are conditoinal expressions with a non-boolean conditional, which by operational semantics will evaluate to $\eerror$.
    \end{enumerate}

    All other cases will result in the computation taking more than one step to reach $\eerror$.

    \textbf{Inductive step: }$C[\eval] \smallsteps[n] \eerror$

    In this part of the proof, I'll be using some of the notations and lemmas introduced in \textit{From Operational to Denotational Semantics} by Scott F. Smith.

    Let's examine the first step in the given computation, which is effectively $C[\eval] \smallstep[] \expr_1$ for some intermediate evaluation result, $\expr_1$.
    
    By corollary 3.5 in the above mentioned paper, we know that there exists unique $\redcon{\circ}{\bullet}$ and $C'[\circ]$ such that $C[\circ] = \redcon{\circ}{C'[\circ]}$, and $C'[v]$ is a redex or $C'[\circ] = \circ$.

    Since $\eval$ is a value, we don't have to consider the case where $C'[\circ] = \circ$, since a value by itself cannot be a redex. This leaves us with the case where $C'[\eval]$ is a redex. There are two main scenarios to consider:

    \begin{enumerate}
      \item If $C'$ doesn't have holes: This suggests that neither $\eval$ nor $\eval'$ will appear in the redex, $r$. In this case, we know that $r \smallsteps[] c$, and that $\redcon{\eval}{r} \smallsteps[] \redcon{\eval}{c}$. Since $\redcon{\eval}{c} \smallsteps[n'] \eerror$ where $n' < n$, by induction hypothesis, we can conclude that $\redcon{\eval'}{c} \smallsteps[] \eerror$. Since we know that $\redcon{\eval'}{r} \smallsteps[] \redcon{\eval'}{c}$, we can conclude that $\redcon{\eval'}{r} \smallsteps[] \eerror$.
      \item If $C'$ does have holes: This suggests that $\eval$ (and in turn, $\eval'$) will appear in the redex. We'll proceed by case analysis on the redex. Since $\eval$, a function value, is in the redex, $C'[\eval]$, we know that $C'[\eval]$ cannot take the forms listed in the base case, since they will result in an error immediately. This leaves us with the following cases:
      \begin{enumerate}
        \item $C'[\eval] = \eval \ \eval_0$: In this case, $C[\eval'] = \eval' \ \eval_0$. Because $\models \hastype{\eval}{\mkfun{\syntype_1}{\syntype_2}}$, we know that if $\models \hastype{\eval_0}{\syntype_1}$, then $\eval \ \eval_0 \smallsteps[] \eval_{r1}$ and $\models \hastype{\eval_{r1}}{\syntype_2}$. 
        
        Since we know that $\redcon{\eval}{C'[\eval]} \smallsteps[] \redcon{\eval}{\eval_{r1}}$, and that $\redcon{\eval}{C'[\eval]} \smallsteps[] \eerror$, we know that 
        $\redcon{\eval}{\eval_{r1}} \smallsteps[] \eerror$. Since it's a smaller computation, by induction hypothesis, we can conclude that $\redcon{\eval'}{\eval_{r1}} \smallsteps[] \eerror$.

        Because $\eval \subseteq_{\mkfun{\syntype_1}{\syntype_2}} \eval'$, we know that $\models \hastype{\eval'}{\mkfun{\syntype_1}{\syntype_2}}$. This in turn gives us $\eval \ \eval_0 \smallsteps[] \eval_{r2}$ and $\models \hastype{\eval_{r2}}{\syntype_2}$. Furthermore, we know that $\eval_{r1} \subseteq_{\syntype_2} \eval_{r2}$ by definition of $\eval \subseteq_{\mkfun{\syntype_1}{\syntype_2}} \eval'$. Since $\syntype_2$ is a smaller type, by induction hypothesis, we can conclude that if $\not \models \hastype{\redcon{\eval'}{\eval_{r1}}}{\syntype_0}$, then $\not \models \hastype{\redcon{\eval'}{\eval_{r2}}}{\syntype_0}$. Since we've proven that $\redcon{\eval'}{\eval_{r1}} \smallsteps[] \eerror$, the premise is true, thus we can safely conclude $\not \models \hastype{\redcon{\eval'}{\eval_{r2}}}{\syntype_0}$.

        \item $C'[\eval] = \eval_f \ \eval$ where $\eval_f = \mkfunv{\ev}{\expr_f}$: In this case, $C[\eval'] = \eval_f \ \eval'$. By operational semantics, we know that $\redcon{\eval}{C'[\eval]} \smallstep[] \redcon{\eval}{\substitute{\expr_f}{\eval}{\ev}}$. We can rewrite $\substitute{\expr_f}{\eval}{\ev}$ as $C''[\eval]$, where the holes are where the $\ev$'s were originally. Therefore, we have $\redcon{\eval}{C''[\eval]} \smallsteps[n-1] \eerror$. Since it's a smaller computation, we can use the  induction hypothesis to conclude that $\redcon{\eval'}{C''[\eval']} \smallsteps[] \eerror$. Since $C''[\eval'] = \substitute{\expr_f}{\eval'}{\ev}$, we know that $\redcon{\eval}{C'[\eval']} \smallstep[] \redcon{\eval}{C''[\eval]}$, thus proving $\redcon{\eval}{C'[\eval']} \smallsteps[] \eerror$.
        
        \item $C'[\eval] = \ife{\gttrue}{\expr_1}{\expr_2}$: If $\expr_1 \neq \eval$, then both $C'[\eval]$ and $C'[\eval']$ will evaluate to $\expr_2$, and the rest of the computation will follow by inductive hypothesis. We only need to consider where $\expr_1 = \eval$. In this case, $C'[\eval] \smallstep[] \eval$, thus $\redcon{\eval}{C'[\eval]} \smallstep[] \redcon{\eval}{\eval}$ and $\redcon{\eval}{\eval} \smallsteps[n-1] \eerror$. By induction hypothesis, we have $\redcon{\eval'}{\eval'} \smallsteps[] \eerror$. Since $C'[\eval'] = \ife{\gttrue}{\eval'}{\expr_2}$, we know that $\redcon{\eval'}{C'[\eval']} \smallstep[] \redcon{\eval'}{\eval'}$, showing that $\redcon{\eval'}{C'[\eval']} \smallsteps[] \eerror$.
        
        \item $C'[\eval] = \ife{\gtfalse}{\expr_1}{\expr_2}$: The proof for this is identical to the last case, so we'll omit it here for brevity.
      \end{enumerate}
    \end{enumerate}

  \end{proof}

  Now we'll show that if $\expr \smallsteps[] \eval_f$ and that $\not \models \hastype{\eval_f}{\mkfun{\syntype_1}{\syntype_2}}$, then $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\eval_f} \smallsteps[] \eerror$. 
    
  By definition of $\not \models \hastype{\eval_f}{\mkfun{\syntype_1}{\syntype_2}}$, we know that there must exist some $\eval_0$ such that $\models \hastype{\eval_0}{\syntype_1}$ and $\not \models \hastype{\eval_f \ \eval_0}{\syntype_2}$.
  
  Unpacking the $\texttt{checker}$ definition, we have $\letin{\texttt{arg}}{\mkgen{\syntype_1}}{\mkche{\syntype_2}{\eval_f \ \texttt{arg}}}$. By lemma 2.6, we have $\models \hastype{\mkgen{\syntype_1}}{\syntype_1}$. By lemma 2.8, we know that $\eval_0 \subseteq_{\syntype_1} \mkgen{\syntype_1}$. Since $\not \models \hastype{\eval_f \ \eval_0}{\syntype_2}$, by lemma 2.9, we can conclude that $\not \models \hastype{\eval_f \ \mkgen{\syntype_1}}{\syntype_2}$. Since $\syntype_2$ is a smaller type, by induction hypothesis, we can conclude that $\mkche{\eval_f \ \texttt{arg}}{\syntype_2} \smallsteps[] \eerror$, thus the overall expression, $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\eval_f} \smallsteps[] \eerror$.

\end{proof}

\section{Language extensions}

Next, we will define a couple of languages extensions and their corresponding typing rules.

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
              \cdots
              \gor \vpoly
            }
            \grule[values]{\eval}{
              \cdots
              \gor \vpoly
            }
            \grule[types]{\syntype}{
              \cdots
              \gor \tpoly
              \gor \mkunion{\syntype}{\syntype}
              \gor \mkintersect{\syntype}{\syntype}
              \gor \mktset{\syntype}{\expr}
              \gor \mkdfun{\ev}{\syntype}{\syntype}
              \gor \mkmiu{\alpha}{\syntype}
          }
        \end{grammar}
    \caption{Extended language grammar}
    \label{ext_Grammar}
\end{figure}

\begin{definition}[More typing rules]
  \label{def_typingRulesExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\tpoly}$ iff $\expr \smallsteps[] \vpoly$, where $\textsc{typeof}(\vpoly) = \tpoly$.
      \item $\ \models \hastype{\expr}{\mkunion{\syntype_1}{\syntype_2}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall \eval.$ if $\expr \smallsteps[] \eval$, then $\ \models \hastype{\eval}{\syntype_1}$ or $\ \models \hastype{\eval}{\syntype_2}$.
      \item $\ \models \hastype{\expr}{\mkintersect{\syntype_1}{\syntype_2}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall \eval.$ if $\expr \smallsteps[] \eval$, then $\ \models \hastype{\eval}{\syntype_1}$ and $\ \models \hastype{\eval}{\syntype_2}$.
      \item $\ \models \hastype{\expr}{\mktset{\syntype}{p}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall \eval.$ if $\expr \smallsteps[] \eval$, \\ then $\ \models \hastype{\eval}{\syntype}$ and $p \ \eval \smallsteps[] \gttrue$.
      \item $\ \models \hastype{\expr}{\mkdfun{\ev}{\syntype_1}{\syntype_2}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall{\eval_f}$, if $\expr \smallsteps[] \eval_f$, \\ then $\forall \eval$, if $\models \hastype{\eval}{\syntype_1}$, then $\models \hastype{\eval_f\ \eval}{\substitute{\syntype_2}{\eval}{\ev}}$.
      \item $\ \models \hastype{\expr}{\mkmiu{\alpha}{\syntype}}$ iff ?.
  \end{enumerate}
\end{definition}

We will now extend the language with records.


\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
              \cdots
              \gor \{\overline{\elbl = \expr}\}^{\{\overline{\elbl}\}}
              \gor \expr.\elbl
            }
            \grule[values]{\eval}{
              \cdots
              \gor \{\overline{\elbl = \eval}\}^{\{\overline{\elbl}\}}
            }
            \grule[types]{\syntype}{
              \cdots
              \gor \{\overline{\hastype{\elbl}{\syntype}}\} 
          }
        \end{grammar}
    \caption{Extended language grammar (with records)}
    \label{rec_Grammar}
\end{figure}

\begin{definition}[Record typing rules]
  \label{def_typingRec}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\{\hastype{\elbl_1}{\syntype_1},\ \cdots, \hastype{\elbl_m}{\syntype_m}\}}$ iff $\expr \bigstep \{\elbl_1 = \eval_1,\ \cdots, \elbl_m = \eval_m,\ \cdots, \elbl_n = \eval_n\}^{\{\elbl_1, \cdots, \elbl_p\}}$ where $\ \models \hastype{\eval_i}{\syntype_i}$ for $i \in \{1,\ \cdots, m\}$, $n \geq p \geq m$.
  \end{enumerate}
\end{definition}

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \ev
                \gor \gtfun\ \ev \gtarrow \expr
                \gor \expr\ \expr
                \gor \expr \ \binop \ \expr
                \gor \vpoly
                \gor \{\overline{\elbl = \expr}\}^{\{\overline{\elbl}\}}
                \gor \expr.\elbl
                \gline
                \gor \ife{\expr}{\expr}{\expr}
                \gor \pick_i
                \gor \pick_b
                \gor \matches{\expr}{p}
                \gor \mzero
                \gor \eerror
                \gline
                \gor \letin{\ev}{\expr}{\expr}
                \gor \letfun
                \gline
                \gor \letfunt
                \gor \letint{\ev}{\syntype}{\expr}{\expr}
            }
            \grule[variables]{\ev}{
                \textit{(identifiers)}
            }
            \grule[patterns]{p}{
                \tint
                \gor \tbool
                \gor \gtfun
                \gor \gtany
                \gor \vpoly
                \gor \{\overline{\elbl}\}
            }
            \grule[values]{\eval}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \gtfun\ \ev \gtarrow \expr
                \gor \ev
                \gor \vpoly
                \gor \{\overline{\elbl = \eval}\}^{\{\overline{\elbl}\}}
            }
            \grule[types]{\syntype}{
                \tint
                \gor \tbool
                \gor \tfun
                \gor \tpoly
                \gor \mkunion{\syntype}{\syntype}
                \gor \mkintersect{\syntype}{\syntype}
                \gor \mktset{\syntype}{\expr}
                \gor \mkdfun{\ev}{\syntype}{\syntype}
                \gor \mkmiu{\alpha}{\syntype}
                \gor \{\overline{\hastype{\elbl}{\syntype}}\}
          }
        \end{grammar}
    \caption{Complete language grammar}
    \label{fig_completeGrammar}
\end{figure}

\section{Type as values}

In this section, we will demonstrate how to represent each type using a tuple of functions $\genf$ and $\chef$.

\begin{definition}[Semantic interpretation of types]
  \label{def_typeAsVal}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  We define the semantic interpretation of types as $\llbracket \syntype \rrbracket = \{\texttt{gen = \mkgen{\syntype}, check = }\mkfunv{\expr}{\mkche{\syntype}{\expr}}\}$.
\end{definition}

\begin{definition}[Defining Generator in the core language]
  \label{def_genCore}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkgen{\tint} : \pick_i$.
    \item $\mkgen{\tbool} : \pick_b$.
    \item $\mkgen{\mkfun{\syntype_1}{\syntype_2}} : \mkfunv{\ev}{\mkgen{\syntype_2}}$.
  \end{enumerate}
\end{definition}

\begin{definition}[Defining Checker in the core language]
  \label{def_CheCore}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkche{\tint}{\expr} : \matches{\expr}{\tint}$.
    \item $\mkche{\tbool}{\expr} : \matches{\expr}{\tbool}$.
    \item $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\expr} : \texttt{let arg = }\mkgen{\syntype_1} \texttt{ in }\mkche{\syntype_2}{\texttt{(e arg)}}$.
  \end{enumerate}
\end{definition}

\begin{definition}[Defining Generator in the extended language]
  \label{def_genExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkgen{\tpoly_i} : \vpoly_i$.
    \item $\mkgen{\mkunion{\syntype_1}{\syntype_2}} : \pick_b$. $\ife{b}{\mkgen{\syntype_1}}{\mkgen{\syntype_2}}$.
    \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where $\syntype_1, \syntype_2$ are not arrow types or record types : $\pick \ b \in \mathbb{B}$. \\ 
    $\texttt{if }b\texttt{ then }$
    $\\\texttt{\ \ let gend = }\mkgen{\syntype_1}\texttt{ in }$
    $\\ \texttt{\ \ if }\mkche{\syntype_2}{\texttt{gend}}\texttt{ then gend else } \mzero$
    $\\ \texttt{else}$
    $\\\texttt{\ \ let gend = }\mkgen{\syntype_2}\texttt{ in }$
    $\\ \texttt{\ \ if }\mkche{\syntype_1}{\texttt{gend}}\texttt{ then gend else } \mzero$   
    \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where $\syntype_1 = \mkfun{\syntype_{dom1}}{\syntype_{cod1}}, \syntype_2 = \mkfun{\syntype_{dom2}}{\syntype_{cod2}} : $ \\ $\mkfunv{\ev}{\\
      \texttt{\ \ }\ife{\mkche{\syntype_{dom1}}{\ev}}{\mkgen{\syntype_{cod1}}}{\mkgen{\syntype_{cod2}}}
    }$. 
    \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where \\ 
    $\syntype_1 = \{\hastype{\elbl_1}{\syntype_1'}, \cdots, \hastype{\elbl_n}{\syntype_n'}, \cdots, \hastype{\elbl_{11}}{\syntype_{11}'}, \cdots, \hastype{\elbl_{1m}}{\syntype_{1m}'}\}, 
    \\ \syntype_2 = \{\hastype{\elbl_1}{\syntype_1''}, \cdots, \hastype{\elbl_n}{\syntype_n''}, \cdots, \hastype{\elbl_{21}}{\syntype_{21}''}, \cdots, \hastype{\elbl_{2n}}{\syntype_{2n}''}\} : $ \\ 
    $\{\elbl_1 = \mkgen{\mkintersect{\syntype_1'}{\syntype_1''}}, \cdots, \elbl_n = \mkgen{\mkintersect{\syntype_n'}{\syntype_n''}}, \cdots, \elbl_{11} = \syntype_{11}, \cdots, \elbl_{2n} = \syntype_{2n}'\}$. 
    \item $\mkgen{\mktset{\syntype}{p}} : $ \\ 
    $\texttt{let gend = }\mkgen{\syntype} \texttt{ in } \ife{\texttt{(p gend)}}{\texttt{gend}}{\mzero}.$
    \item $\mkgen{\mkdfun{\ev}{\syntype_1}{\syntype_2}} : $
    \\$\mkfunv{\ev'}{\ife{\mkche{\tau_1}{\ev'}}{\mkgen{\substitute{\syntype_2}{\ev'}{\ev}}}{\eerror}}.$
    \item $\mkgen{\mkmiu{\alpha}{\syntype}} : \mkgen{\substitute{\syntype}{\alpha}{\mkmiu{\alpha}{\syntype}}}.$
    \item $\mkgen{\{\hastype{\elbl_1}{\syntype_1}, \cdots, \hastype{\elbl_n}{\syntype_n}\}} :$ \\ $\texttt{let }\eval_1 = \mkgen{\syntype_1}\texttt{ in }\cdots\texttt{ let }\eval_n = \mkgen{\syntype_n}\texttt{ in } \{\elbl_1 = \eval_1, \cdots, \elbl_n = \eval_n\}.$
  \end{enumerate}
\end{definition}

\begin{definition}[Defining Checker in the extended language]
  \label{def_cheExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkche{\tpoly_i}{\expr} : \matches{\expr}{\vpoly_i}$.
    \item $\mkche{\mkunion{\syntype_1}{\syntype_2}}{\expr} : \mkche{\syntype_1}{\expr} \texttt{ or } \mkche{\syntype_2}{\expr}$.
    \item $\mkche{\mkintersect{\syntype_1}{\syntype_2}}{\expr} : \mkche{\syntype_1}{\expr} \texttt{ and } \mkche{\syntype_2}{\expr}$. 
    \item $\mkche{\mktset{\syntype}{p}}{\expr} : \mkche{\syntype}{\expr} \texttt{ and } \evaluate{\expr} = \gttrue$.
    \item $\mkche{\mkdfun{\ev}{\syntype_1}{\syntype_2}}{\expr} : \texttt{let arg = } \mkgen{\syntype_1} \texttt{ in } \mkche{\substitute{\syntype_2}{\texttt{arg}}{\ev}}{\texttt{(e arg)}}$.
    \item $\mkche{\mkmiu{\alpha}{\syntype}}{\expr} : \mkche{\substitute{\syntype}{\mkmiu{\alpha}{\syntype}}{\alpha}}{\expr}$.
    \item $\mkche{\{\hastype{\elbl_1}{\syntype_1}, \cdots, \hastype{\elbl_m}{\syntype_m}\}}{\expr} :$
    $\evaluate{\expr} = \{\elbl_1 = \eval_1, \cdots, \elbl_m = \eval_m, \cdots, \elbl_n = \eval_n\}^{\{\elbl_1, \cdots, \elbl_m\}}$ \\ 
    $\texttt{and } \mkche{\syntype_1}{\eval_1} \cdots \texttt{ and } \mkche{\syntype_m}{\eval_m}$.
  \end{enumerate}
\end{definition}

\section{Selective typechecking}

We allow users to declare types in their program selectively. If an expression doesn't have a type declaration, we assume that the user does not wish for us to check its type. In other words, we will only be checking explicitly declared types in the user program.

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
                \cdots
                \gor \letfunt
                \gor \letint{\ev}{\syntype}{\expr}{\expr}
            }
        \end{grammar}
    \caption{Updated language grammar}
    \label{fig_updatedGrammar}
\end{figure}

% For presentation

% \begin{figure}[hbt!]%{r}{.5\textwidth}%
%   \begin{grammar}
%             \grule[expressions]{\expr}{
%                 \cdots
%                 \gor \letfunt
%                 \gline
%                 \gor \letint{\ev}{\syntype}{\expr}{\expr}
%             }
%             \grule[types]{\syntype}{
%               \cdots
%               \gor \mktset{\syntype}{\expr}
%               \gor \mkdfun{\ev}{\syntype}{\syntype}
%             }
%         \end{grammar}
%     \caption{Updated language grammar}
%     \label{fig_updatedGrammar}
% \end{figure}

% \begin{definition}[Defining Generator in the extended language]
%   \label{def_genExt}
%   % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
%   \ \par 
%   \begin{enumerate}
%     \item $\mkgen{\mktset{\syntype}{p}} : $ \\ 
%     $\texttt{let gend = }\mkgen{\syntype} \texttt{ in } \ife{\texttt{(p gend)}}{\texttt{gend}}{\mzero}.$
%     \item $\mkgen{\mkdfun{\ev}{\syntype_1}{\syntype_2}} : $
%     \\$\mkfunv{\ev'}{\ife{\mkche{\tau_1}{\ev'}}{\mkgen{\substitute{\syntype_2}{\ev'}{\ev}}}{\eerror}}.$
%   \end{enumerate}
% \end{definition}

% \begin{definition}[Defining Checker in the extended language]
%   \label{def_cheExt}
%   % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
%   \ \par 
%   \begin{enumerate}
%     \item $\mkche{\mktset{\syntype}{p}}{\expr} : $\\ 
%     $\mkche{\syntype}{\expr} \texttt{ and } \evaluate{\expr} = \gttrue$.
%     \item $\mkche{\mkdfun{\ev}{\syntype_1}{\syntype_2}}{\expr} :$\\ 
%     $\texttt{let arg = } \mkgen{\syntype_1} \texttt{ in } \mkche{\substitute{\syntype_2}{\texttt{arg}}{\ev}}{\texttt{(e arg)}}$.
%   \end{enumerate}
% \end{definition}

% \begin{definition}[Refinement type]
%   $\ \models \hastype{\expr}{\mktset{\syntype}{p}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall \eval.$ if $\expr \smallsteps[] \eval$, 
  
%   then $\ \models \hastype{\eval}{\syntype}$ and $p \ \eval \smallsteps[] \gttrue$.

%   \begin{itemize}
%     \item $\mkche{\mktset{\syntype}{p}}{\expr} : $\\ 
%     $\letin{\_}{\mkche{\syntype}{\expr}}{\ife{(p \  e)}{e}{\eerror}}$
%     \item $\mkgen{\mktset{\syntype}{p}} : $ \\ 
%     $\texttt{let gend = }\mkgen{\syntype} \texttt{ in } \ife{\texttt{(p gend)}}{\texttt{gend}}{\mzero}$
%   \end{itemize}
% \end{definition}

% \pagebreak

% \begin{definition}[Dependent type]
%   $\ \models \hastype{\expr}{\mkdfun{\ev}{\syntype_1}{\syntype_2}}$ iff $\expr \nsmallsteps[] \eerror$, and $\forall{\eval_f}$, if $\expr \smallsteps[] \eval_f$, 
  
%   then $\forall \eval$, if $\models \hastype{\eval}{\syntype_1}$, then $\models \hastype{\eval_f\ \eval}{\substitute{\syntype_2}{\eval}{\ev}}$.

%   \begin{itemize}
%     \item $\mkche{\mkdfun{\ev}{\syntype_1}{\syntype_2}}{\expr} :$\\ 
%     $\texttt{let arg = } \mkgen{\syntype_1} \texttt{ in } \mkche{\substitute{\syntype_2}{\texttt{arg}}{\ev}}{\texttt{(e arg)}}$
%     \item $\mkgen{\mkdfun{\ev}{\syntype_1}{\syntype_2}} : $
%     \\$\mkfunv{\ev'}{\letin{\_}{\mkche{\tau_1}{\ev'}}{\mkgen{\substitute{\syntype_2}{\ev'}{\ev}}}}$
%   \end{itemize}
% \end{definition}

