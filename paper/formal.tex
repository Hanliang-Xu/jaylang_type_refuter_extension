\section{Intro}

Here is a formalization of our type system.

\section{Core Language}

First, we'll define a small core language with basic integers, booleans, and functions.

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \ev
                \gor \gtfun\ \ev \gtarrow \expr
                \gor \expr\ \expr
            }
            \grule[variables]{\ev}{
                        \textit{(identifiers)}
            }
            \grule[values]{\eval}{
                \mathbb{Z}
                \gor \mathbb {B}
                \gor \gtfun\ \ev \gtarrow \expr
                \gor \ev
            }
            \grule[types]{\syntype}{
              \tint
              \gor \tbool
              \gor \tfun
          }
        \end{grammar}
    \caption{Core language grammar}
    \label{fig_Grammar}
\end{figure}

The typing rules of the system is defined as following:

\begin{definition}[Typing rules]
  \label{def_typingRules}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\tint}$ iff $\expr \bigstep \eval$, $\eval \in \mathbb{Z}$.
      \item $\ \models \hastype{\expr}{\tbool}$ iff $\expr \bigstep \eval$, $\eval \in \mathbb{B}$.
      \item $\ \models \hastype{\expr}{\mkfun{\syntype_1}{\syntype_2}}$ iff $\forall{\eval}$ such that $\models \hastype{\eval}{\syntype_1}$, $\models \hastype{\expr\ \eval}{\syntype_2}$.
   \end{enumerate}
\end{definition}

\section{Language extensions}

Next, we will define a couple of languages extensions and their corresponding typing rules.

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
              \cdots
              \gor \vpoly
            }
            \grule[values]{\eval}{
              \cdots
              \gor \vpoly
            }
            \grule[types]{\syntype}{
              \cdots
              \gor \tpoly
              \gor \mkunion{\syntype}{\syntype}
              \gor \mkintersect{\syntype}{\syntype}
              \gor \mktset{\syntype}{\expr}
              \gor \mkdfun{\ev}{\syntype}{\syntype}
              \gor \mkmiu{\alpha}{\syntype}
          }
        \end{grammar}
    \caption{Extended language grammar}
    \label{ext_Grammar}
\end{figure}

\begin{definition}[More typing rules]
  \label{def_typingRulesExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\tpoly_i}$ iff $\expr \bigstep \vpoly_i$.
      \item $\ \models \hastype{\expr}{\mkunion{\syntype_1}{\syntype_2}}$ iff $\ \models \hastype{\expr}{\syntype_1}$ or $\ \models \hastype{\expr}{\syntype_2}$.
      \item $\ \models \hastype{\expr}{\mkintersect{\syntype_1}{\syntype_2}}$ iff $\ \models \hastype{\expr}{\syntype_1}$ and $\ \models \hastype{\expr}{\syntype_2}$.
      \item $\ \models \hastype{\expr}{\mktset{\syntype}{p}}$ iff $\ \models \hastype{\expr}{\syntype}$ and $p \ \expr \Longrightarrow \gttrue$.
      \item $\ \models \hastype{\expr}{\mkdfun{\ev}{\syntype_1}{\syntype_2}}$ iff $\forall{\eval}$ such that $\models \hastype{\eval}{\syntype_1}$, $\models \hastype{\expr\ \eval}{\substitute{\syntype_2}{\eval}{\ev}}$.
      \item $\ \models \hastype{\expr}{\mkmiu{\alpha}{\syntype}}$ iff $\hastype{\expr}{\substitute{\syntype}{\mkmiu{\alpha}{\syntype}}{\alpha}}$.
  \end{enumerate}
\end{definition}

We will now extend the language with records.

\begin{figure}[hbt!]%{r}{.5\textwidth}%
  \begin{grammar}
            \grule[expressions]{\expr}{
              \cdots
              \gor \{\overline{\elbl = \expr}\}^{\{\overline{\elbl}\}}
              \gor \expr.\elbl
            }
            \grule[values]{\eval}{
              \cdots
              \gor \{\overline{\elbl = \eval}\}^{\{\overline{\elbl}\}}
            }
            \grule[types]{\syntype}{
              \cdots
              \gor \{\overline{\hastype{\elbl}{\syntype}}\} 
          }
        \end{grammar}
    \caption{Extended language grammar (with records)}
    \label{rec_Grammar}
\end{figure}

\begin{definition}[Record typing rules]
  \label{def_typingRec}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par
  \begin{enumerate}
      \item $\ \models \hastype{\expr}{\{\hastype{\elbl_1}{\syntype_1},\ \cdots, \hastype{\elbl_m}{\syntype_m}\}}$ iff $\expr \bigstep \{\elbl_1 = \eval_1,\ \cdots, \elbl_m = \eval_m,\ \cdots, \elbl_n = \eval_n\}^{\{\elbl_1, \cdots, \elbl_m\}}$ where $\ \models \hastype{\eval_i}{\syntype_i}$ for $i \in \{1,\ \cdots, m\}$, $n \geq m$
  \end{enumerate}
\end{definition}

\section{Type as values}

In this section, we will demonstrate how to represent each type using a tuple of functions $\genf$ and $\chef$.

\begin{definition}[Semantic interpretation of types]
  \label{def_typeAsVal}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  We define the semantic interpretation of types as $\llbracket \syntype \rrbracket$, where $\llbracket \syntype \rrbracket = \langle \mkgen{\syntype}, \mkche{\syntype}{\expr} \rangle$.
\end{definition}

\begin{definition}[Defining Generator in the core language]
  \label{def_genCore}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkgen{\tint} : \pick \ n \in \mathbb{Z}$.
    \item $\mkgen{\tbool} : \pick \ b \in \mathbb{B}$.
    \item $\mkgen{\mkfun{\syntype_1}{\syntype_2}} : \mkfunv{\ev}{\mkgen{\syntype_2}}$.
  \end{enumerate}
\end{definition}

\begin{definition}[Defining Checker in the core language]
  \label{def_CheCore}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkche{\tint}{\expr} : \matches{\expr}{\tint}$.
    \item $\mkche{\tbool}{\expr} : \matches{\expr}{\tbool}$.
    \item $\mkche{\mkfun{\syntype_1}{\syntype_2}}{\expr} : \texttt{let arg = }\mkgen{\syntype_1} \texttt{ in }\mkche{\syntype_2}{\texttt{(e arg)}}$.
  \end{enumerate}
\end{definition}

\begin{definition}[Defining Generator in the extended language]
  \label{def_genExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkgen{\tpoly_i} : \vpoly_i$.
    \item $\mkgen{\mkunion{\syntype_1}{\syntype_2}} : \pick \ b \in \mathbb{B}$. $\ife{b}{\mkgen{\syntype_1}}{\mkgen{\syntype_2}}$.
    \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where $\syntype_1, \syntype_2$ are not arrow types : $\pick \ b \in \mathbb{B}$. \\ 
    $\ife{b}{\texttt{let gend = } \mkgen{\syntype_1} \texttt{ in }\take{\mkche{\syntype_2}{\texttt{gend}}}{\texttt{gend}}
    }{\\ \texttt{let gend = } \mkgen{\syntype_2} \texttt{ in }\take{\mkche{\syntype_1}{\texttt{gend}}}{\texttt{gend}}
    }$.
    \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where $\syntype_1 = \mkfun{\syntype_{dom1}}{\syntype_{cod1}}, \syntype_2 = \mkfun{\syntype_{dom2}}{\syntype_{cod2}} : $ \\ 
    $\mkfunv{\ev}{
      \ife{\mkche{\syntype_{dom1}}{\ev}}{\mkgen{\syntype_{cod1}}}{\\\mkgen{\syntype_{cod2}}}
    }$. 
    \item $\mkgen{\mkintersect{\syntype_1}{\syntype_2}}$ where \\ $\syntype_1 = \{\hastype{\elbl_1}{\syntype_1}, \cdots, \hastype{\elbl_m}{\syntype_m}\}, \syntype_2 = \{\hastype{\elbl_1}{\syntype_1}, \cdots, \hastype{\elbl_m}{\syntype_m}, \cdots, \hastype{\elbl_n}{\syntype_n}\} : $ \\ 
    $\mkfunv{\ev}{
      \ife{\mkche{\syntype_{dom1}}{\ev}}{\mkgen{\syntype_{cod1}}}{\\\mkgen{\syntype_{cod2}}}
    }$. 
    \item $\mkgen{\mktset{\syntype}{p}} : \texttt{let choice = }\mkgen{\syntype} \texttt{ in } \take{p}{choice}.$
    \item $\mkgen{\mkdfun{\ev}{\syntype_1}{\syntype_2}} : \texttt{let $\tau_2'$ = }\mkfunv{\ev}{\syntype_2} \texttt{ in }\mkfunv{\ev'}{\mkgen{\tau_2'\ \ev'}}.$
    \item $\mkgen{\mkmiu{\alpha}{\syntype}} : \mkgen{\substitute{\syntype}{\alpha}{\mkmiu{\alpha}{\syntype}}}.$
    \item $\mkgen{\{\hastype{\elbl_1}{\syntype_1}, \cdots, \hastype{\elbl_n}{\syntype_n}\}} :$ \\ $\texttt{let }\eval_1 = \mkgen{\syntype_1}\texttt{ in }\cdots\texttt{ let }\eval_n = \mkgen{\syntype_n}\texttt{ in } \{\elbl_1 = \eval_1, \cdots, \elbl_n = \eval_n\}.$
  \end{enumerate}
\end{definition}

\begin{definition}[Defining Checker in the extended language]
  \label{def_cheExt}
  % \label{def_ppred} \label{def_ifx} \label{def_ifbranch} \label{def_retcl}
  \ \par 
  \begin{enumerate}
    \item $\mkche{\tpoly_i}{\expr} : \matches{\expr}{\vpoly_i}$.
    \item $\mkche{\mkunion{\syntype_1}{\syntype_2}}{\expr} : \mkche{\syntype_1}{\expr} \texttt{ or } \mkche{\syntype_2}{\expr}$.
    \item $\mkche{\mkintersect{\syntype_1}{\syntype_2}}{\expr} : \mkche{\syntype_1}{\expr} \texttt{ and } \mkche{\syntype_2}{\expr}$. 
    \item $\mkche{\mktset{\syntype}{p}}{\expr} : \mkche{\syntype}{\expr} \texttt{ and } \evaluate{\expr} = \gttrue$.
    \item $\mkche{\mkdfun{\ev}{\syntype_1}{\syntype_2}}{\expr} : \texttt{let arg = } \mkgen{\syntype_1} \texttt{ in } \mkche{\substitute{\syntype_2}{\texttt{arg}}{\ev}}{\texttt{(e arg)}}$.
    \item $\mkche{\mkmiu{\alpha}{\syntype}}{\expr} : \mkche{\substitute{\syntype}{\mkmiu{\alpha}{\syntype}}{\alpha}}{\expr}$.
    \item $\mkche{\{\hastype{\elbl_1}{\syntype_1}, \cdots, \hastype{\elbl_m}{\syntype_m}\}}{\expr} :$
    $\evaluate{\expr} = \{\elbl_1 = \eval_1, \cdots, \elbl_m = \eval_m, \cdots, \elbl_n = \eval_n\}^{\{\elbl_1, \cdots, \elbl_m\}}$ \\ 
    $\texttt{and } \mkche{\syntype_1}{\eval_1} \cdots \texttt{ and } \mkche{\syntype_m}{\eval_m}$.
  \end{enumerate}
\end{definition}