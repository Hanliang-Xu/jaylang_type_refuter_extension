**Motivation:**  Why refutation-based type-checking?
- Inspired by works on symbolic execution and contracts, we wish to explore the concept of types beyond traditional static type systems, which mainly rely on syntax-directed proof rules for type checking. Our approach is more dynamic in that we rely on symbolic execution to detect type errors in a program. Since symbolic execution can capture a lot of information only determinable at runtime, we can check for more complex and expressive types. Furthermore, our method is not a whole-program analysis. We can check for any portion of the program as long as any invoked non-local components come with type declarations. 
- (Potential problem: the type declarations on the non-local components might not be precise enough)
- Modular: Use only the abstract (the type declaration) of the non-local component <- if the supplied type is not precise enough, we won't be able to typecheck this (since it's relying on a false premise)
- Global: Use the concrete code of the non-local component
- Anohter big difference between our system and the conventional type system is that instead of checking for "type correctness" in a program, we focus on checking for "type incorrectness": our tool is guaranteed to find any type error in the program if one exists; however, if the program is in fact type correct, our tool is not guaranteed to terminate with a proof of its type correctness. This might feel like a major limitation of our system, but we will argue later why this might not be as bad as it might seem.
- In our system, types are represented as a pair of functions: "the generator" and "the checker". The names are quite self-explanatory: the generator function will produce an arbitrary value of the specified type, whereas the checker function, when given a value, will determine whether or not that value belongs to the type. To ensure soundness of our type-checking, we require that the two functions must be symmetric: any value that can be produced by the generator should pass the checker, and any value that can pass the checker should be producable by the generator. This requirement poses certain challenges for more complex features such as subtyping and intersection types. We will address the limitations introduced by this requirement later in the paper.

**Design:** How does it work?  
- The concept behind our type checking is quite simple: we first rewrite the program by translating type declarations into type-checking code, which is in essence calling the coresponding checker function on the typed expression. Any failed checks will intercept the contorl flow and lead to a type error. Then, we run symbolic execution on the rewritten program. Any symbolic run reaching a type error is a proof that the declared type on the expression is incorrect.
- Our system currently supports the following types: int, bool, record type, list type, function type, dependent type, set type, union and intersection types, recursive types, and parametric polymorphism.
- Chekcing base types such as int and bool is quite simple. However, checking for function types requires a bit more work. Correctness of a function type, t -> t', is defined as follows in our system: for all inputs of type t, the function will produce a value of type t'. To check for correctness, the checker will fabricate arguments according to the declared types on the parameters. Then, after calling the function on these values, the checker of the return type will determine whether the return value has the correct type.
- An observant reader might have noticed that the check discussed above is only checking for the correctness of function declarations. In a traditional type system, type checking will automatically check for the type correctness of both the definition and usage of a function. However, in our system, the two checks are carried out separately. The checker for function type is only responsible for checking the correctness of the definition; usage checks are handled by "wrapping"--an instrumentation process similar to how contracts are translated into wrappers around a typed expression.
- 
- Since symbolic execution cannot model infinite control flows in finite time, in cases of recurisve types and types on recursive values in general, our system will not terminate when the declared type is in fact correct.

**Evaluation:** How well does it work?
- The main advantage of this representation is its expressiveness. In this system, we can easily represent complex types such as union and intersection type, set type, dependent type, or even data structures such as balanced binary tree and etc. As long as there exists a symmetric function encoding of the value set, we can represent that set as a valid type.
- A big challenge for a refutation-based system like this is that a forward symbolic execution might spend a lot of time exploring unrelated paths before diving into the control flow that will lead to an actual error. We alleviate this problem by using a demand-driven symbolic execution, which is capable of starting in an arbitrary point in the program and search backwards for a path to the top of the program. This ensures that all the control-flow paths that the symbolic execution explores are in fact relavant to the potential errors that we are interested in.


**TODO:**
- Other type of record: unprobable records? <- records will carry metadata about what the legal fields to match on are <-- add to the system
- Chew on functors -- type declaration on functors
- Modules <- Can our system do modules without adding additional feature?