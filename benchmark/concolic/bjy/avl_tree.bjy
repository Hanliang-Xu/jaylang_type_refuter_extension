# This is an avl tree program, where insert on balanced tree returns a balanced tree
# There is a type error in `insert`. See the comment
# Other ways to introduce a type error:
# 1. Don't rotate at all
# 2. Rotate left only on left insert, and right only on right insert (this was my first bug)
#
# The current type error does not get caught with 10,000 max step, tree depth 50 (to 100), timeout 300 seconds.
# Difficulties:
# 1. Needs lots of constraints to create well-formed tree
# 2. `is_balanced` is necessarily recursive, so it is a costly constraint to check
# 3. Needs types on rotate functions and wrapped, or else can hit runtime non-abort error, but then we are type-checking many functions in the same file

let is_pos x = x > 0 in
let max a b = if a > b then a else b in

let height x =
  match x with
  | { leaf = b } -> 0
  | { height = h , _ } -> h
  end
in

let t = Mu tt. ({. {: left : tt, right : tt, item : int, height : {. int | is_pos } :} | fun t -> t.height == max (height t.left) (height t.right) + 1} || {: leaf : bool :}) in

# short-circuiting `and` -- necessary for types on rotate functions
let and_ b1 b2 =
  if b1
  then b2 0
  else false
in

let is_leaf (x : t) : bool =
  match x with
  | { leaf = b } -> true
  | { _ } -> false
  end
in

let item_exn x =
  match x with
  | { item = i , _ } -> i
  end
in

let left_exn x =
  match x with
  | { left = left , _ } -> left
  end
in

let right_exn x =
  match x with
  | { right = right , _ } -> right
  end
in

let empty = { leaf = true } in

let balance_factor x =
  match x with
  | { leaf = leaf } -> 0
  | { left = left , right = right , _ } -> height left - height right
  end
in

let abs a = if a > 0 then a else (0 - a) in

let rec is_balanced x =
  match x with
  | { leaf = leaf } -> true
  | { left = left , right = right, _ } -> abs (balance_factor x) < 2 and is_balanced left and is_balanced right
  end
in

# This `is_balanced` is not sufficient because it doesn't check children
#let is_balanced x =
#  abs (balance_factor x) < 2
#in


let create_node item left right =
  { item = item , left = left , right = right , height = 1 + max (height left) (height right) }
in

# use short-circuiting `and` in the type
#let rotate_left (x : {. t | fun x -> and_ (not (is_leaf x)) (fun y -> not (is_leaf (right_exn x)))}) : t = 
let rotate_left x = 
  match x with
  | { item = item , left = left , right = right , _ } ->
    match right with
    | { item = ri , left = rleft , right = rright , _ } ->
      create_node ri (create_node item left rleft) rright
    end
  end
in

# use short-circuiting `and` in the type
#let rotate_right (x : {. t | fun x -> and_ (not (is_leaf x)) (fun y -> not (is_leaf (left_exn x)))}) : t =
let rotate_right x = 
  match x with
  | { item = item , left = left , right = right , _ } ->
    match left with
    | { item = li , left = lleft , right = lright , _ } ->
      create_node li lleft (create_node item lright right)
    end 
  end
in

let rotate_left_right x =
  match x with
  | { item = item , left = left , right = right , _ } -> rotate_right (create_node item (rotate_left left) right)
  end
in

let rotate_right_left x =
  match x with
  | { item = item , left = left , right = right , _ } -> rotate_left (create_node item left (rotate_right right))
  end
in

let rec insert (tree : {. t | is_balanced }) (i : int) : {. t | is_balanced } =
#let rec insert tree i =
  let rebalance i node =
    let bf = balance_factor node in
    if bf > 1
    then
      if i < item_exn (left_exn node)
      then rotate_left node # should be rotate_right
      else rotate_left_right node
    else
      if bf < (0 - 1)
      then
        if i > item_exn (right_exn node)
        then rotate_left node
        else rotate_right_left node
      else
        node
  in
  match tree with
  | { leaf = b } -> create_node i { leaf = true } { leaf = true }
  | { item = item , left = left , right = right , _ } ->
      let new_node =
        if i < item 
        then create_node item (insert left i) right
        else
          if i > item
          then create_node item left (insert right i)
          else tree
      in
      rebalance i new_node
  end
in

insert

