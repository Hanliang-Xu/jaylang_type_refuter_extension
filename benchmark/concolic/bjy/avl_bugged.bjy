# This program has a bug because on insert, it only balances one way on the left insert
# and one way on the right insert. It should try balancing in all ways on either insert.
# Therefore, `insert` is not well typed because it does not always return a balanced tree.

let is_pos x = x > 0 in

let t = Mu tt. ({: left : tt, right : tt, item : int, height : {. int | is_pos } :} || {: leaf : bool :}) in

let empty = { leaf = true } in

let height x =
  match x with
  | { leaf = b } -> 0
  | { height = h , _ } -> h
  end
in

let balance_factor x =
  match x with
  | { leaf = leaf } -> 0
  | { left = left , right = right , _ } -> height left - height right
  end
in

let abs a = if a > 0 then a else (0 - a) in

let is_balanced x =
  abs (balance_factor x) < 2
in

# This correct is_balanced seems to make it too difficult to type check insert
# let rec is_balanced (x : t) : bool =
#   match x with
#   | { leaf = leaf } -> true
#   | { left = left , right = right, _ } -> abs (balance_factor x) < 2 and is_balanced left and is_balanced right
#   end
# in

let max a b = if a > b then a else b in

let create_node item left right =
  { item = item , left = left , right = right , height = 1 + max (height left) (height right) }
in

let rotate_left x =
  match x with
  | { item = item , left = left , right = right , _ } ->
    match right with
    | { item = ri , left = rleft , right = rright , _ } ->
      create_node ri (create_node item left rleft) rright
    end
  end
in

let rotate_right x =
  match x with
  | { item = item , left = left , right = right , _ } ->
    match left with
    | { item = li , left = lleft , right = lright , _ } ->
      create_node li lleft (create_node item lright right)
    end 
  end
in

let rotate_left_right x =
  match x with
  | { item = item , left = left , right = right , _ } -> rotate_right (create_node item (rotate_left left) right)
  end
in

let rotate_right_left x =
  match x with
  | { item = item , left = left , right = right , _ } -> rotate_left (create_node item left (rotate_right right))
  end
in

let rec insert (tree : {. t | is_balanced }) (i : int) : {. t | is_balanced } =
# let rec insert tree i =
  match tree with
  | { leaf = b } -> create_node i { leaf = true } { leaf = true }
  | { item = item , left = left , right = right , _ } ->
      if i < item
      then
        let new_left = insert left i in
        if balance_factor new_left > 1
        then
          if i < match new_left with { item = ni , _ } -> ni end
          then rotate_right (create_node item new_left right)
          else rotate_left_right (create_node item new_left right)
        else
          create_node item new_left right
      else
        if i > item
        then
          let new_right = insert right i in
          if balance_factor new_right < (0 - 1)
          then
            if i > match new_right with { item = ni , _ } -> ni end
            then rotate_left (create_node item left new_right)
            else rotate_right_left (create_node item left new_right)
          else
            create_node item left new_right
        else
          tree
  end
in

# NOTE: can uncomment the typed `let rec insert ...` above and replace the below lines with `insert` to type check insert

insert

# let a = empty in
# let b = insert a 1 in
# let c = insert b 2 in
# let d = insert c 3 in

# let (b : {. bool | fun y -> y}) = is_balanced d in

# b
