# EXPECT-WELL-FORMED
# EXPECT-INPUT-SEQUENCES-REACH target [ 1, 98, 0, 0, 0, 0, 0, 0, 0 ]
## It cannot output in 5,000,000 steps.

## the original C code check how many args start with 'b', check in `*argv[i]`

let argc = input
in let arg_0 = input
in let arg_1 = input
in let arg_2 = input
in let arg_3 = input
in let arg_4 = input
in let arg_5 = input
in let arg_6 = input
in let arg_7 = input
in let arg_index_at i =
  if i == 0 then arg_0
  else if i == 1 then arg_1
  else if i == 2 then arg_2
  else if i == 3 then arg_3
  else if i == 4 then arg_4
  else if i == 5 then arg_5
  else if i == 6 then arg_6
  else arg_7
##
#for (i = 0; i < argc; i++) {
#    if (*argv[i] == 'b') {
#        assert(n < 4);
#        b[n++] = 1;
#    } else {
#        getchar();
#    }
#}
##
## I feel like I will have to duplicate the conditions "n < 4", or duplicate the innovation of next iteration "loop .. .. ". I prefer the former.

in let rec loop n i = 
  if i == argc
  then 0
  else (
    let arg = arg_index_at i
    in 
      let ignored = 
        ## Char.code 'b' = 98
        if arg == 98
        then (
          if n < 4
          then
            ## b[n++] = 1 is a mutable array
            0
          else
            let target = 42 in target
        )
        else (
          let ignored = input in 0
        )
      in let n_next = 
        if arg == 98 and n < 4
        then n + 1
        else n
      in loop n_next (i+1)
  )
  ## we need require a positive argc, or we could get negative numbers
in if 0 < argc
    then loop 0 0
    else 0