# EXPECT-WELL-FORMED
# EXPECT-ANALYSIS-STACK-IS 1ddpa
# EXPECT-ANALYSIS-LOOKUP-FROM-END r {{}}
# EXPECT-ANALYSIS-NO-INCONSISTENCIES

# (define (phi x1 x2 x3 x4)
#   (and (or x1 (not x2) (not x3))
#        (or (not x2) (not x3))
#        (or x4 x2)))
#
# (define (try f)
#   (or (f #t) (f #f)))
#
# (define (sat-solve-4 p)
#   (try (lambda (n1)
#          (try (lambda (n2)
#                 (try (lambda (n3)
#                        (try (lambda (n4)
#                               (p n1 n2 n3 n4))))))))))
#
# (sat-solve-4 phi)

true = {};
false = 0;

not = fun notp -> (
  notr = notp ~ {}
              ? fun notm -> (
                notmr = false;
              )
              : fun nota -> (
                notar = true;
              );
);

or = fun orparams -> (
  ora = orparams.a;
  orb = orparams.b;
  orbr = ora ~ {}
             ? fun oram -> (
               oram = true;
             )
             : fun oraa -> (
               oraar = orb ~ {}
                           ? fun orbm -> (
                             orbm = true;
                           )
                           : fun orba -> (
                             orbar = false;
                           );
             );
);

and = fun andparams -> (
  anda = andparams.a;
  andb = andparams.b;
  andbr = anda ~ {}
             ? fun andam -> (
               andaar = andb ~ {}
                           ? fun andbm -> (
                             andbm = true;
                           )
                           : fun andba -> (
                             andbar = false;
                           );
             )
             : fun andaa -> (
               andam = false;
             );
);

phi = fun phiparams -> (
  x1 = phiparams.x1;
  x2 = phiparams.x2;
  x3 = phiparams.x3;
  x4 = phiparams.x4;
  notx2 = not x2;
  notx3 = not x3;

  orx1notx2params = {a = x1, b = notx2};
  orx1notx2 = or orx1notx2params;
  orx1notx2notx3params = {a = orx1notx2, b = notx3};
  orx1notx2notx3 = or orx1notx2notx3params;
  notx22 = not x2;
  notx32 = not x3;
  ornotx2notx3params = {a = notx22, b = notx32};
  ornotx2notx3 = or ornotx2notx3params;
  orx4x2params = {a = x4, b = x2};
  orx4x2 = or orx4x2params;
  andorx1notx2orx1notx2notx3params = {a = orx1notx2, b = orx1notx2notx3};
  andorx1notx2orx1notx2notx3 = and andorx1notx2orx1notx2notx3params;
  andorx1notx2orx1notx2notx3orx4x2params = {a = andorx1notx2orx1notx2notx3, b = orx4x2};
  andorx1notx2orx1notx2notx3orx4x2 = and andorx1notx2orx1notx2notx3orx4x2params;
);

try = fun f -> (
  ft = f true;
  ff = f false;
  orftffparams = {a = ft, b = ff};
  orftff = or orftffparams;
);

satsolve4 = fun p -> (
  fn1 = fun n1 -> (
    fn2 = fun n2 -> (
      fn3 = fun n3 -> (
        fn4 = fun n4 -> (
          pparams = {x1 = n1, x2 = n2, x3 = n3, x4 = n4};
          fn4r = p pparams;
        );
        tryfn4 = try fn4;
      );
      tryfn3 = try fn3;
    );
    tryfn2 = try fn2;
  );
  tryfn1 = try fn1;
);

r = satsolve4 phi;
