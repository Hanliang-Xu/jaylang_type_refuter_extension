# EXPECT-WELL-FORMED
# EXPECT-ANALYSIS-STACK-IS 1ddpa
# EXPECT-ANALYSIS-LOOKUP-FROM-END r {{}}
# EXPECT-ANALYSIS-NO-INCONSISTENCIES

# (letrec ((id (lambda (x) x))
#
#          (blur (lambda (y) y))
#
#          (lp (lambda (a n)
#                (if (<= n 1)
#                    (id a)
#                    (let* ((r ((blur id) #t))
#                           (s ((blur id) #f)))
#                      (not ((blur lp) s (- n 1))))))))
#   (lp #f 2))

true = {};
false = 0;

# Inlined.
#
# not = fun notp -> (
#   notr = notp ~ {}
#               ? fun notm -> (
#                 notmr = false;
#               )
#               : fun nota -> (
#                 notar = true;
#               );
# );

one = 1;
two = 2;

id = fun x -> (
  idr = x;
);

blur = fun y -> (
  blurr = y;
);

lpp = fun lppr -> (
  lpprr = fun lpprparams -> (
    a = lpprparams.a;
    n = lpprparams.n;
    nl = n <= one;
    nr = nl ~ {}
            ? fun nlm -> (
              nlmr = id a;
            )
            : fun nla -> (
              rf = blur id;
              r = rf true;
              sf = blur id;
              s = sf false;
              lpr = lppr lppr;
              blurlp = blur lpr;
              n1 = n - one;
              blurlpsn1params = {a = s, n = n1};
              blurlpsn1 = blurlp blurlpsn1params;
              nlar = blurlpsn1 ~ {}
                               ? fun notm -> (
                                 notmr = false;
                               )
                               : fun nota -> (
                                 notar = true;
                               );
            );
  );
);

lp = lpp lpp;

lpparams = {a = false, n = two};
r = lp lpparams;
