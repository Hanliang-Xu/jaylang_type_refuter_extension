{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "Bluejay",
  "scopeName": "source.bluejay",
  "patterns": [
    {"include": "#comments"},
    {"include": "#numbers"},
    {"include": "#keywords"},
    {"include": "#operators"},
    {"include": "#identifiers"},
    {"include": "#brackets"}
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.block.bluejay",
          "begin": "\\(\\*",
          "end": "\\*\\)",
          "patterns": [
            {"include": "#comments"}
          ]
        }
      ]
    },
    
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.integer.bluejay",
          "match": "\\b[0-9]+\\b"
        }
      ]
    },
    
    "keywords": {
      "patterns": [
        {
          "name": "keyword.other.bluejay",
          "match": "\\b(if|then|else|match|with|end|let|rec|in|fun|val|sig|struct|of|dep|dependent|and)\\b"
        },
        {
          "name": "keyword.operator.bluejay",
          "match": "\\b(not)\\b"
        },
        {
          "name": "constant.language.boolean.bluejay",
          "match": "\\b(true|false)\\b"
        },
        {
          "name": "support.type.builtin.bluejay",
          "match": "\\b(int|bool|unit|top|bottom|singlet|list|type)\\b"
        },
        {
          "name": "support.function.builtin.bluejay",
          "match": "\\b(input|assert|assume)\\b"
        },
        {
          "name": "support.type.special.bluejay",
          "match": "\\bMu\\b"
        }
      ]
    },
    
    "operators": {
      "patterns": [
        {
          "name": "keyword.operator.arithmetic.bluejay",
          "match": "[+\\-*/%]"
        },
        {
          "name": "keyword.operator.comparison.bluejay",
          "match": "(===?|<>|<=?|>=?)"
        },
        {
          "name": "keyword.operator.logical.bluejay",
          "match": "(\\|\\||&&)"
        },
        {
          "name": "keyword.operator.pipe.bluejay",
          "match": "\\|>"
        },
        {
          "name": "keyword.operator.cons.bluejay",
          "match": "::"
        },
        {
          "name": "keyword.operator.type.bluejay",
          "match": "(\\||&|->|-->)"
        },
        {
          "name": "keyword.operator.assignment.bluejay",
          "match": "="
        },
        {
          "name": "keyword.operator.type-annotation.bluejay",
          "match": ":"
        },
        {
          "name": "keyword.operator.access.bluejay",
          "match": "\\."
        }
      ]
    },

"identifiers": {
  "patterns": [
    {
      "comment": "wildcard underscore",
      "name": "constant.language.bluejay",
      "match": "\\b_\\b"
    },
    {
      "comment": "function name after val declaration",
      "name": "entity.name.function.bluejay",
      "match": "(?<=\\bval\\s+)([a-z_][[:word:]']*)",
      "captures": {
        "1": {"name": "entity.name.function.bluejay"}
      }
    },
    {
      "comment": "function name in let bindings (followed by parameters)",
      "name": "entity.name.function.bluejay", 
      "match": "(?<=\\blet\\s+(?:rec\\s+)?)([a-z_][[:word:]']*)(?=\\s+(?:\\(type\\s+[^)]+\\)|[a-z_A-Z(]|\\([^)]*:[^)]*\\)))",
      "captures": {
        "1": {"name": "entity.name.function.bluejay"}
      }
    },
    {
      "comment": "type parameters in parentheses",
      "name": "meta.type-parameters.bluejay",
      "match": "\\((type)\\s+([a-z_][[:word:]']*(?:\\s+[a-z_][[:word:]']*)*)\\)",
      "captures": {
        "1": {"name": "keyword.other.bluejay"},
        "2": {"name": "variable.parameter.bluejay"}
      }
    },
    {
      "comment": "function after dot (record/module projection used as function)",
      "name": "entity.name.function.bluejay",
      "match": "(?<=\\.)([a-z_][[:word:]']*)(?=\\s+(?!\\b(?:if|then|else|match|with|end|let|rec|in|fun|val|sig|struct|of|dep|dependent|and)\\b)(?:[a-z_A-Z][[:word:]']*|\\([^)]*\\)|[0-9]+|\\b(?:int|bool|unit|top|bottom|singlet|list|type)\\b))",
      "captures": {
        "1": {"name": "entity.name.function.bluejay"}
      }
    },
    {
      "comment": "fun parameters - all identifiers after fun until ->",
      "name": "variable.parameter.bluejay", 
      "match": "(?<=\\bfun\\s+)([a-z_][[:word:]']*(?:\\s+[a-z_][[:word:]']*)*)(?=\\s*->)",
      "captures": {
        "1": {"name": "variable.parameter.bluejay"}
      }
    },
    {
      "comment": "function call - identifier NOT preceded by another identifier (to avoid matching arguments as functions)",
      "name": "entity.name.function.bluejay",
      "match": "(?<!\\b[a-z_A-Z][[:word:]']*\\s)(?<!\\blet\\s+(?:rec\\s+)?)(?<!\\bval\\s+)(?<!\\.)\\b([a-z_][[:word:]']*)(?=\\s+(?!\\b(?:if|then|else|match|with|end|let|rec|in|fun|val|sig|struct|of|dep|dependent|and|->)\\b)(?:[a-z_A-Z][[:word:]']*|\\([^)]*\\)|[0-9]+|\\b(?:int|bool|unit|top|bottom|singlet|list|type)\\b))",
      "captures": {
        "1": {"name": "entity.name.function.bluejay"}
      }
    },
    {
      "comment": "capital identifier for constructor, exception, or module",
      "name": "entity.name.type.module.bluejay",
      "match": "\\b[[:upper:]][[:word:]']*('|\\b)"
    },
    {
      "comment": "builtin types used as values (including in function arguments)",
      "name": "support.type.builtin.bluejay",
      "match": "\\b(int|bool|unit|top|bottom|singlet|list|type)\\b"
    },
    {
      "comment": "lowercase identifier (default case)",
      "name": "variable.other.bluejay",
      "match": "\\b[[:lower:]_][[:word:]']*('|\\b)"
    },
    {
      "comment": "polymorphic variant tag",
      "name": "constant.language.polymorphic-variant.bluejay",
      "match": "\\`[[:alpha:]][[:word:]']*\\b"
    },
    {
      "comment": "empty list (can be used as a constructor)",
      "name": "constant.language.list.bluejay",
      "match": "\\[\\]"
    }
  ]
},

    "brackets": {
      "patterns": [
        {
          "name": "punctuation.section.braces.begin.bluejay",
          "match": "\\{"
        },
        {
          "name": "punctuation.section.braces.end.bluejay",
          "match": "\\}"
        },
        {
          "name": "punctuation.section.brackets.begin.bluejay",
          "match": "\\["
        },
        {
          "name": "punctuation.section.brackets.end.bluejay",
          "match": "\\]"
        },
        {
          "name": "punctuation.section.parens.begin.bluejay",
          "match": "\\("
        },
        {
          "name": "punctuation.section.parens.end.bluejay",
          "match": "\\)"
        },
        {
          "name": "punctuation.section.record.begin.bluejay",
          "match": "\\{:"
        },
        {
          "name": "punctuation.section.record.end.bluejay",
          "match": ":\\}"
        }
      ]
    }
  }
}