# This is a lot like depth_dependent2_tail_rec, but where the sum is not satisfiable.
# This may be a false positive (i.e. passing for the wrong reasons) because sometimes if the
# desired sum is possible but too large, it thinks it is unsatisfiable (though that also
# might be because I am stopping the evaluation early due to bad max step handling).

# How come we keep successfully solving for some input that gets progressively larger?

x = input;

zero = 0;
one = 1;

desired_sum = 60; # not a possible sum of consecutive integers starting at 0

x_is_one_cond = x == one;

f = fun self -> (
    f0 = fun counter -> (
      f1 = fun sum -> (
        is_done = counter == zero;
        r = is_done ? (
          done_val = sum
        ) : (
          ss = self self;
          new_counter = counter - one;
          new_sum = sum + counter;

          # sum_res is the final sum of the whole thing. 
          frozen = ss new_counter;
          sum_res = frozen new_sum;

          sum_val_is_desired_cond = sum_res == desired_sum;
          sum_val_is_desired_branch = sum_val_is_desired_cond ? (
            # unsatisfiable
            res0 = 42
          ) : (
            res1 = 84
          ); # result of branch gets ignored. The point is to hit the branch, not do anything with it
          res = sum_res
        );

      )
    );
);
ff = f f;

neg_1 = -1;
x_is_non_neg = neg_1 < x;
call_fun_branch = x_is_non_neg ? (
  z = ff x; # apply counter
  z2 = z zero # apply starting sum
) : (
  w = 0
)