# This has a "tail recursive" sum, where the desired sum value is checked
# while backtracking.
# This test case appears to be failing. It doesn't seem like it can solve for this.
# When max step is handled, we should just get an inconclusive result on this.
# Update: it is working, but only for small inputs. desired input 11 works, but not 35
#   This is strange because some inputs larger than 35 don't hit the max step

x = input;

zero = 0;
one = 1;

desired_sum = 66; # 630 for input 35

f = fun self -> (
    f0 = fun counter -> (
      f1 = fun sum -> (
        is_done = counter == zero;
        r = is_done ? (
          done_val = sum
        ) : (
          ss = self self;
          new_counter = counter - one;
          new_sum = sum + counter;

          # sum_res is the final sum of the whole thing. 
          frozen = ss new_counter;
          sum_res = frozen new_sum;

          sum_val_is_desired_cond = sum_res == desired_sum;
          sum_val_is_desired_branch = sum_val_is_desired_cond ? (
            # input x exactly 11 hits this
            res0 = 42
          ) : (
            res1 = 84
          ); # result of branch gets ignored. The point is to hit the branch, not do anything with it
          res = sum_res
        );

      )
    );
);
ff = f f;

neg_1 = -1;
x_is_non_neg = neg_1 < x;
call_fun_branch = x_is_non_neg ? (
  z = ff x; # apply counter
  z2 = z zero # apply starting sum
) : (
  w = 0
)