
# Depending on input, a recursive function might get called that times out.
# The right inputs can avoid this and hit other branches.
# The goal is to test that reaching the max step down some branches does
# not prevent the evaluator from hitting other independent branches

# Currently it thinks r true is unsatisfiable. I should test by making max step very small
# and manually working out formulas

x = input;
one = 1;
zero = 0;

f = fun self -> (
  f0 = fun counter -> (
    is_done = counter == zero; # max step maybe reached here
    r = is_done ? (
      # end case won't be reached because of max step
      done_val = zero
    ) : (
      # max step likely reached here
      ss = self self;
      new_counter = counter - one;
      res = ss new_counter;
      sum_val = counter + res;
    );
  );
);
ff = f f;

counter0 = 500;

large = 100;

cm = x < large; # always true on first run

first_branch = cm ? (
  # always hit on first run
  fifty = 50;
  x_is_50 = x == fifty; # arbitrary non-timeout case
  x_is_50_branch = x_is_50 ? (
    x_is_50_ret = 49 # reachable despite timeout on other side
  ) : (
    # Times out. Always hit on first run
    z = ff counter0
  )
) : (
  non_timeout_res = 101 
);

c = x == first_branch; # true when x = 101
e = c ? (
  # hittable when x = 101
  # Could be "unknown" because is hard to solve for when so many formulas clog up the solver, so it times out.
  target = 42
) : (
  # hittable when x > 101 or x = 50
  void = 0
)
