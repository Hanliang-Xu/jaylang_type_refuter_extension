# This has a condition that can only be satisfied when it's at a
# specific recursive depth.
# Right now, targets that are found most recently are targeted first,
# which is at the wrong depth, so it looks unsatisfiable.
# A quick path (which I won't do) would be to not ignore unsatisfiable
# branches and try to resolve every time.
#   This would be expensive because it is way more solving than necessary.

x = input;

zero = 0;
one = 1;

x_is_one_cond = x == one;

f = fun self -> (
    f0 = fun counter -> (
        second_to_last_iter_cond = counter == one;
        unsatisfiable_on_last_iter_cond = x_is_one_cond and second_to_last_iter_cond;
        unsatisfiable_on_last_iter = unsatisfiable_on_last_iter_cond ? (
          do_nothing1 = 0
        ) : (
          do_nothing2 = 0
        );

        is_done = counter == zero;
        r = is_done ? (
              done_val = zero
            ) : (
              ss = self self;
              new_counter = counter - one;
              res = ss new_counter;
              sum_val = counter + res
            );
    );
);
ff = f f;
x3 = 3;
z = ff x3;