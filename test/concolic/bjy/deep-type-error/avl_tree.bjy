# This is an avl tree program, where insert on balanced tree returns a balanced tree
# There is a type error in `insert`. See the comment
# Other ways to introduce a type error:
# 1. Don't rotate at all
# 2. Rotate left only on left insert, and right only on right insert (this was my first bug)
#
# The current type error does not get caught with 50,000 max step, tree depth 50 (to 100, even), timeout 300 seconds.
# Difficulties:
# 1. Needs lots of constraints to create well-formed tree
# 2. `is_balanced` is necessarily recursive, so it is a costly constraint to check
# 3. Needs types on rotate functions and wrapped, or else can hit runtime non-abort error, but then we are type-checking many functions in the same file

# Seems like we have to get lucky to hit this. With the typical seed, we hit an error in 19 seconds.
# With BFS search only, we don't hit it in 10 minutes. Bad look...
# It also times out at 10 minutes when uncurried

let is_pos x = x > 0 in
let max a b = if a > b then a else b in

let height x =
  match x with
  | `Leaf l -> 0
  | `Node node -> node.height
  end
in

let t = Mu tt. 
  (  ``Node {.
              {: left : tt
              , right : tt
              , item : int
              , height : {. int | is_pos }
              :}
            | fun t -> t.height == max (height t.left) (height t.right) + 1
            }
  || ``Leaf {: leaf : bool :}
  )
in

# short-circuiting `and` -- necessary for types on rotate functions
let and_ b1 b2 =
  if b1
  then b2 0
  else false
in

#let is_leaf (x : t) : bool =
let is_leaf x =
  match x with
  | `Leaf l -> true
  | _ -> false
  end
in

let item_exn x =
  match x with
  | `Node node -> node.i
  end
in

let left_exn x =
  match x with
  | `Node node -> node.left
  end
in

let right_exn x =
  match x with
  | `Node node -> node.right
  end
in

let empty = `Leaf { leaf = true } in

let balance_factor x =
  match x with
  | `Leaf leaf -> 0
  | `Node node -> height node.left - height node.right
  end
in

let abs a = if a > 0 then a else (0 - a) in

let rec is_balanced x =
  match x with
  | `Leaf leaf -> true
  | `Node node -> abs (balance_factor x) < 2 and is_balanced node.left and is_balanced node.right
  end
in

# This `is_balanced` is not sufficient because it doesn't check children
#let is_balanced x =
#  abs (balance_factor x) < 2
#in

let create_node item left right =
  `Node { item = item , left = left , right = right , height = 1 + max (height left) (height right) }
in

# use short-circuiting `and` in the type
#let rotate_left (x : {. t | fun x -> and_ (not (is_leaf x)) (fun y -> not (is_leaf (right_exn x)))}) : t = 
let rotate_left x = 
  match x with
  | `Node node ->
    match node.right with
    | `Node right_node -> 
      create_node right_node.item (create_node node.item node.left right_node.left) right_node.right
    end
  end
in

# use short-circuiting `and` in the type
#let rotate_right (x : {. t | fun x -> and_ (not (is_leaf x)) (fun y -> not (is_leaf (left_exn x)))}) : t =
let rotate_right x = 
  match x with
  | `Node node ->
    match node.left with
    | `Node left_node ->
      create_node left_node.item left_node.left (create_node node.item left_node.right node.right)
    end 
  end
in

let rotate_left_right x =
  match x with
  | `Node node -> rotate_right (create_node node.right (rotate_left node.left) node.right)
  end
in

let rotate_right_left x =
  match x with
  | `Node node -> rotate_left (create_node node.item node.left (rotate_right node.right))
  end
in

let rec insert (r : {: tree : {. t | is_balanced } , i : int :}) : {. t | is_balanced } =
  let rebalance i node =
    let bf = balance_factor node in
    if bf > 1
    then
      if i < item_exn (left_exn node)
      then rotate_left node           # ERROR HERE! should be rotate_right
      else rotate_left_right node
    else
      if bf < (0 - 1)
      then
        if i > item_exn (right_exn node)
        then rotate_left node
        else rotate_right_left node
      else
        node
  in
  match r.tree with
  | `Leaf l -> create_node r.i (`Leaf { leaf = true }) (`Leaf { leaf = true })
  | `Node node ->
    match node with
    | { item = item , left = left , right = right , _ } ->
      let new_node =
        if r.i < item 
        then create_node item (insert { tree = left , i = r.i }) right
        else
          if r.i > item
          then create_node item left (insert { tree = right , i = r.i })
          else r.tree
      in
      rebalance r.i new_node
    end
  end
in

#let rec insert (tree : {. t | is_balanced }) (i : int) : {. t | is_balanced } =
#  let rebalance i node =
#    let bf = balance_factor node in
#    if bf > 1
#    then
#      if i < item_exn (left_exn node)
#      then rotate_left node           # ERROR HERE! should be rotate_right
#      else rotate_left_right node
#    else
#      if bf < (0 - 1)
#      then
#        if i > item_exn (right_exn node)
#        then rotate_left node
#        else rotate_right_left node
#      else
#        node
#  in
#  match tree with
#  | `Leaf l -> create_node i (`Leaf { leaf = true }) (`Leaf { leaf = true })
#  | `Node node ->
#    match node with
#    | { item = item , left = left , right = right , _ } ->
#      let new_node =
#        if i < item 
#        then create_node item (insert left i) right
#        else
#          if i > item
#          then create_node item left (insert right i)
#          else tree
#      in
#      rebalance i new_node
#    end
#  end
#in

insert

