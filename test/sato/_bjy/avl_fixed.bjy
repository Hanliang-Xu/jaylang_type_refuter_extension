let is_pos x = x > 0 in

let t = Mu tt. ({: left : tt, right : tt, item : int, height : {. int | is_pos } :} || {: leaf : bool :}) in

# let is_leaf x =
#   match x with
#   | { leaf = b } -> true
#   | { _ } -> false
#   end
# in

let item_exn x =
  match x with
  | { item = i , _ } -> i
  end
in

let left_exn x =
  match x with
  | { left = left , _ } -> left
  end
in

let right_exn x =
  match x with
  | { right = right , _ } -> right
  end
in

let empty = { leaf = true } in

let height x =
  match x with
  | { leaf = b } -> 0
  | { height = h , _ } -> h
  end
in

let balance_factor x =
  match x with
  | { leaf = leaf } -> 0
  | { left = left , right = right , _ } -> height left - height right
  end
in

let abs a = if a > 0 then a else (0 - a) in

# let rec is_balanced x =
#   match x with
#   | { leaf = leaf } -> true
#   | { left = left , right = right, _ } -> abs (balance_factor x) < 2 and is_balanced left and is_balanced right
#   end
# in

let is_balanced x =
  abs (balance_factor x) < 2
in

let max a b = if a > b then a else b in

let create_node item left right =
  { item = item , left = left , right = right , height = 1 + max (height left) (height right) }
in

let rotate_left x = 
  match x with
  | { item = item , left = left , right = right , _ } ->
    match right with
    | { item = ri , left = rleft , right = rright , _ } ->
      create_node ri (create_node item left rleft) rright
    end
  end
in

let rotate_right x =
  match x with
  | { item = item , left = left , right = right , _ } ->
    match left with
    | { item = li , left = lleft , right = lright , _ } ->
      create_node li lleft (create_node item lright right)
    end 
  end
in

let rotate_left_right x =
  match x with
  | { item = item , left = left , right = right , _ } -> rotate_right (create_node item (rotate_left left) right)
  end
in

let rotate_right_left x =
  match x with
  | { item = item , left = left , right = right , _ } -> rotate_left (create_node item left (rotate_right right))
  end
in

let rec insert (tree : {. t | is_balanced }) (i : int) : {. t | is_balanced } =
  let rebalance i node =
    let bf = balance_factor node in
    if bf > 1
    then
      if i < item_exn (left_exn node)
      then rotate_right node
      else rotate_left_right node
    else
      if bf < (0 - 1)
      then
        if i > item_exn (right_exn node)
        then rotate_left node
        else rotate_right_left node
      else
        node
  in
  match tree with
  | { leaf = b } -> create_node i { leaf = true } { leaf = true }
  | { item = item , left = left , right = right , _ } ->
      let new_node =
        if i < item 
        then create_node item (insert left i) right
        else
          if i > item
          then create_node item left (insert right i)
          else tree
      in
      rebalance i new_node
  end
in

insert

