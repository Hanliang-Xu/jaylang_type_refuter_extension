(***
  (
    (speed Fast)
    (typing Ill_typed)
    (flags "")
  )
*)

(*
module type arg = sig type arg end
module A = struct type arg end

module Add_one' = struct
  module M(_:arg) = A
  module type t = module type of M
end

module Add_one = struct type witness include Add_one' end

module Add_three = struct
  module M(_:arg)(_:arg)(_:arg) = A
  module type t = module type of M
  type witness
end

module F(X:sig type witness module type t module M:t end) = X.M

module Choose_one = F(Add_one')(Add_three)(A)(A)(A)
*)

let arg = sig val arg : type end
let A = struct let arg = abstract end

let Add_one_ = struct
  let M (_ : arg) : arg = A
  let t = arg -> arg (* we don't have "module type of", so I have to spell this out *)
end

let Add_one = struct
  let witness = abstract 
  let M = Add_one_.M
  let t = Add_one_.t
end

let Add_three = struct
  let M (_ : arg) (_ : arg) (_ : arg) : arg = A
  let t = arg -> arg -> arg -> arg
  let witness = abstract
end

(* This type and the next module are taken from abstract_module_type *)
let TF = (X : sig
  val witness : type
  val t : type (* we should add subtypes so we can say this is a subtype of sig end, and that way it's definitely a module type *)
  val M : t
end) -> X.t

let F : TF = fun X -> X.M

(* ERROR: (Add_one_) is an extra argument, and it is lacking witness. If it did have witness, the last (A) would be application to a non function *)
let Choose_one = F (Add_one_) (Add_three) (A) (A) (A)