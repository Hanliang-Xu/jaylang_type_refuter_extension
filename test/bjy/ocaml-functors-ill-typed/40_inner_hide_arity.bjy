(***
  (
    (features (Polymorphic_types Dependent_types Modules First_class_types Higher_order_functions Subtyping))
    (reasons (Polymorphic_types Modules Subtyping Higher_order_functions))
    (speed Fast)
    (typing Ill_typed)
    (flags "")
  )
*)

(*
module M: sig
  module F(_:sig end)(X:
           sig
             module type T
             module type inner = sig
               module type t
               module M: t
             end
             module F(X: inner)(_:T -> T->T):
             sig module type res = X.t end
             module Y: sig
               module type t = T -> T -> T
               module M(X:T)(Y:T): T
             end
           end):
    X.F(X.Y)(X.Y.M).res
end = struct
  module F(_:sig type wrong end) (X:
             sig  module type T end
          )(Res: X.T)(Res: X.T)(Res: X.T) = Res
end
*)

let M : sig
  val F : sig end -> (X : sig
      val T : type
      val inner = sig
          val t : type
          val M : t
        end
      val F : (X : inner) -> (T -> T -> T) -> sig
          val res = X.t
        end
      val Y : sig
        val t = T -> T -> T
        val M : T -> T -> T
      end
    end) -> (X.F (X.Y) (X.Y.M)).res
end = struct
  (*
    ERROR: the first argument is a subtype of the one stated above, so this function
      is a supertype.
      There is also an extra `Res` argument.
  *)
  let F (_ : sig val wrong : type end) (dependent X :
      sig val T : type end
    ) (Res : X.T) (Res : X.T) (Res : X.T) : X.T = Res
end