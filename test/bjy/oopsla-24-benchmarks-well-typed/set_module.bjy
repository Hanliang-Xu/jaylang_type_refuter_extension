(***
  (
    (features (Polymorphic_types Refinement_types Dependent_arrows Modules Mu_types Parametric_types First_class_types Variants Records Recursive_functions Higher_order_functions Subtyping OOP_style Return_error Usage_error Other))
    (reasons (Polymorphic_types Refinement_types Dependent_arrows Modules Mu_types Parametric_types First_class_types Variants Records Recursive_functions Higher_order_functions Subtyping OOP_style Return_error Usage_error Other))
    (speed <Fast or Slow>)
    (typing <Well_typed or Ill_typed>)
  )
*)
(*** (
  (features (Recursive_functions Higher_order_functions Parametric_types Records Return_type))
) *)

let Set : (a : type) -> sig
  val t : type
  val emptyset : t
  val add : a -> t -> t
  val remove : a -> t -> (a -> a -> bool) -> t
  val contains : a -> t -> (a -> a -> bool) -> bool
end = fun a -> struct
  let t = list a

  let emptyset = []

  let add x s = x :: s 

  let rec remove x s equal = 
    match s with
    | [] -> []
    | hd :: tl ->
      if equal hd x
      then tl
      else hd :: remove x tl equal
    end

  let rec contains x s equal = 
    match s with
    | [] -> false
    | hd :: tl ->
      if equal x hd
      then true
      else contains x tl equal
    end
end
