(***
  (
    (features (Refinement_types Dependent_types Recursive_functions))
    (reasons (Refinement_types Recursive_functions))
    (speed Fast) 
    (typing Ill_typed) ; only because of incompleteness with type splaying
    (flags "-s")
  )
*)

let non_neg = { i : int | i >= 0 }

(*
  The problem is that the recursive call generates a value with a stronger (but still
  different) refinement, whose stub then does not check as intensionally equal to the
  present return type's stub.
*)
let rec range (dep a : non_neg) (dep b : non_neg | b >= a) : list { x : int | a <= x && x < b } =
  if a == b
  then []
  else a :: range (a + 1) b