
let T = sig
  val t : type
  val elt : type
  val empty : t
  val add : t -> elt -> t
end

let F (X <- T) : { of_list : list X.elt -> X.t } =
  { of_list = fun ls -> 
    let rec loop acc ls =
      match ls with
      | [] -> acc
      | hd :: tl -> loop (X.add acc hd) tl
      end
    in
    loop X.empty ls
  }

let (M : T) = { elt = int ; t = list int ; empty = [] ; add = fun ls a -> a :: ls }

let X = F M 
