(***
  (
    (features (Polymorphic_types Refinement_types Dependent_arrows Modules Mu_types Parametric_types First_class_types Variants Records Recursive_functions Higher_order_functions Subtyping OOP_style Return_error Usage_error Other))
    (reasons (Polymorphic_types Refinement_types Dependent_arrows Modules Mu_types Parametric_types First_class_types Variants Records Recursive_functions Higher_order_functions Subtyping OOP_style Return_error Usage_error Other))
    (speed <Fast or Slow>)
    (typing <Well_typed or Ill_typed>)
  )
*)

let F (tf <- type -> type) (a <- type) :
  let t = tf a in
  { empty : unit -> t
  ; add   : a -> t -> t
  }
  ->
  { of_list : list a -> t
  }
  =
  fun r ->
    { of_list =
      fun ls ->
        let rec loop acc ls =
          match ls with
          | [] -> acc
          | hd :: tl -> loop (r.add hd acc) tl
          end
        in
        loop (r.empty {}) ls
    }
