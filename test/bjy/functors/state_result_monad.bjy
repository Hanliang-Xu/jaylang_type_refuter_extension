
(*
  This is supposed to be well-typed, but the current system
  finds it to be ill-typed because of nondeterminism of generated
  type functions.
*)

let T = { t : type }

let (M : (State : T) -> (Err : T) ->
  {: m    : type -> type
  ;  bind : (a : type) -> (b : type) -> m a -> (a -> m b) -> m b
  ;  return : (a : type) -> a -> m a
  ;  fail   : (a : type) -> Err.t -> m a
  :})
  =
  fun State Err ->
    { m = fun a -> (* a is the type parameter *)
      (r : type) -> (* r is the result forall type *)
        (Err.t -> r) -> (a -> State.t -> r) -> State.t -> r
    ; bind = fun a b -> (* a, b aren't actually used. They are only for type-checking *)
        fun x f ->
          fun r -> (* This r gets propagated. It stays the same *)
            fun reject accept s ->
              x r reject (fun a s ->
                f a r reject accept s
              ) s
    ; return = fun a -> (* again just used for type checking *)
        fun res ->
          fun r -> (* result type *)
            fun reject accept s ->
              accept res s
    ; fail = fun a -> (* .. *)
        fun err -> (* error value *)
          fun r -> (* result type *)
              fun reject accept s ->
                reject err
    }
